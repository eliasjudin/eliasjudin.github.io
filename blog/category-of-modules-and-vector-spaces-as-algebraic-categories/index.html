<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Modules and Vector Spaces as Algebraic Categories — Elias Judin</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Exercises in category theory: category of modules and category of vector spaces as algebraic categories"><meta name=robots content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=theme-color content="#ffffff"><meta name=author content="Elias Judin"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><link rel=canonical href=https://eliasjudin.github.io/blog/category-of-modules-and-vector-spaces-as-algebraic-categories/><meta property="og:url" content="https://eliasjudin.github.io/blog/category-of-modules-and-vector-spaces-as-algebraic-categories/"><meta property="og:title" content="Modules and Vector Spaces as Algebraic Categories — Elias Judin"><meta property="og:description" content="Exercises in category theory: category of modules and category of vector spaces as algebraic categories"><meta property="og:type" content="article"><meta property="og:site_name" content="Elias Judin"><meta property="og:image" content="https://eliasjudin.github.io/assets/images/banner-social.png"><meta property="og:image:alt" content="Modules and Vector Spaces as Algebraic Categories — Elias Judin"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Modules and Vector Spaces as Algebraic Categories — Elias Judin"><meta name=twitter:description content="Exercises in category theory: category of modules and category of vector spaces as algebraic categories"><meta name=twitter:image content="https://eliasjudin.github.io/assets/images/banner-social.png"><meta name=twitter:image:alt content="Modules and Vector Spaces as Algebraic Categories — Elias Judin"><link rel=alternate type=application/rss+xml title="Elias Judin" href=https://eliasjudin.github.io/index.xml><meta property="article:published_time" content="2022-06-26T18:56:48+02:00"><meta property="article:modified_time" content="2025-12-24T23:20:35+02:00"><link rel=icon type=image/svg+xml href=/favicon.svg><link rel=preload href=/css/style.min.f1d49839b721c9f35bcda8b272d1ca57dcd26b1c6dfd19cd3d9d6686095413ec.css as=style integrity="sha256-8dSYObchyfNbzaiyctHKV9zSaxxt/RnNPZ1mhglUE+w=" crossorigin=anonymous><link rel=stylesheet href=/css/style.min.f1d49839b721c9f35bcda8b272d1ca57dcd26b1c6dfd19cd3d9d6686095413ec.css integrity="sha256-8dSYObchyfNbzaiyctHKV9zSaxxt/RnNPZ1mhglUE+w=" crossorigin=anonymous media=print onload='this.media="all"'><noscript><link rel=stylesheet href=/css/style.min.f1d49839b721c9f35bcda8b272d1ca57dcd26b1c6dfd19cd3d9d6686095413ec.css integrity="sha256-8dSYObchyfNbzaiyctHKV9zSaxxt/RnNPZ1mhglUE+w=" crossorigin=anonymous></noscript><script defer src=/js/tickers.min.f08a1d80d427b8fb84ae659d7799cba6661e94a2c36e4d9a9e353cce065c6cad.js integrity="sha256-8IodgNQnuPuErmWdd5nLpmYelKLDbk2anjU8zgZcbK0="></script><script type=application/ld+json>[{"@context":"https://schema.org","@id":"https://eliasjudin.github.io/#website","@type":"WebSite","description":"Elias Judin's academic website and mathematics research blog on category theory, universal algebra, topology, and sheaf theory.","inLanguage":"en","name":"Elias Judin","publisher":{"@id":"https://eliasjudin.github.io/#person","@type":"Person","affiliation":[{"@type":"Organization","name":"Harmonic","url":"https://harmonic.fun/"},{"@type":"CollegeOrUniversity","name":"University of Cape Town","url":"https://www.uct.ac.za/"}],"alumniOf":[{"@type":"CollegeOrUniversity","name":"University of Cape Town","url":"https://www.uct.ac.za/"},{"@type":"CollegeOrUniversity","name":"University of the Witwatersrand","url":"https://www.wits.ac.za/"},{"@type":"HighSchool","name":"King David Victory Park High School","url":"https://www.kingdavid.org.za/victory-park-high-school/"}],"award":["Master's Fellowship; UCT Building Research Active Academic Staff Grant (2023, 2024)","Myer Levinson (EMDIN) Scholar (2022, 2023, 2024)","Max Price and Deborah Posel Scholarship nominee (2022)","University Council Merit Scholarship, University of the Witwatersrand (2020, 2021)","Dean's List (University of the Witwatersrand, 2020 Year II, 2021 Year III)"],"jobTitle":"Lean4 mathematician and MSc Mathematics student","knowsAbout":["Category theory","Universal algebra","Topology","Sheaf theory","Lean theorem proving","Quantum computing"],"name":"Elias Judin","sameAs":["https://scholar.google.com/citations?user=fOYPVWwAAAAJ","https://orcid.org/0009-0009-3267-9204","https://www.semanticscholar.org/author/Elias-Judin/2276874240"],"url":"https://eliasjudin.github.io/"},"url":"https://eliasjudin.github.io/"},{"@context":"https://schema.org","@id":"https://eliasjudin.github.io/blog/category-of-modules-and-vector-spaces-as-algebraic-categories/#webpage","@type":"WebPage","description":"Exercises in category theory: category of modules and category of vector spaces as algebraic categories","inLanguage":"en","isPartOf":{"@id":"https://eliasjudin.github.io/#website"},"name":"Modules and Vector Spaces as Algebraic Categories","primaryImageOfPage":{"@type":"ImageObject","url":"https://eliasjudin.github.io/assets/images/banner-social.png"},"url":"https://eliasjudin.github.io/blog/category-of-modules-and-vector-spaces-as-algebraic-categories/"},{"@context":"https://schema.org","@id":"https://eliasjudin.github.io/blog/category-of-modules-and-vector-spaces-as-algebraic-categories/#article","@type":"ScholarlyArticle","author":[{"@type":"Person","name":"Elias Judin"}],"dateModified":"2025-12-24T23:20:35+02:00","datePublished":"2022-06-26T18:56:48+02:00","description":"Exercises in category theory: category of modules and category of vector spaces as algebraic categories","headline":"Modules and Vector Spaces as Algebraic Categories","image":["https://eliasjudin.github.io/assets/images/banner-social.png"],"inLanguage":"en","isPartOf":{"@id":"https://eliasjudin.github.io/#website"},"keywords":"category-theory, universal-algebra","mainEntityOfPage":{"@id":"https://eliasjudin.github.io/blog/category-of-modules-and-vector-spaces-as-algebraic-categories/#webpage","@type":"WebPage"},"name":"Modules and Vector Spaces as Algebraic Categories","publisher":{"@id":"https://eliasjudin.github.io/#person","@type":"Person","affiliation":[{"@type":"Organization","name":"Harmonic","url":"https://harmonic.fun/"},{"@type":"CollegeOrUniversity","name":"University of Cape Town","url":"https://www.uct.ac.za/"}],"alumniOf":[{"@type":"CollegeOrUniversity","name":"University of Cape Town","url":"https://www.uct.ac.za/"},{"@type":"CollegeOrUniversity","name":"University of the Witwatersrand","url":"https://www.wits.ac.za/"},{"@type":"HighSchool","name":"King David Victory Park High School","url":"https://www.kingdavid.org.za/victory-park-high-school/"}],"award":["Master's Fellowship; UCT Building Research Active Academic Staff Grant (2023, 2024)","Myer Levinson (EMDIN) Scholar (2022, 2023, 2024)","Max Price and Deborah Posel Scholarship nominee (2022)","University Council Merit Scholarship, University of the Witwatersrand (2020, 2021)","Dean's List (University of the Witwatersrand, 2020 Year II, 2021 Year III)"],"jobTitle":"Lean4 mathematician and MSc Mathematics student","knowsAbout":["Category theory","Universal algebra","Topology","Sheaf theory","Lean theorem proving","Quantum computing"],"name":"Elias Judin","sameAs":["https://scholar.google.com/citations?user=fOYPVWwAAAAJ","https://orcid.org/0009-0009-3267-9204","https://www.semanticscholar.org/author/Elias-Judin/2276874240"],"url":"https://eliasjudin.github.io/"},"url":"https://eliasjudin.github.io/blog/category-of-modules-and-vector-spaces-as-algebraic-categories/","wordCount":727}]</script></head><body><a class=vl-skip-link href=#main>Skip to main content</a><div class=vl-page><div class=vl-frame><header class=vl-header role=banner><div class=vl-top><div><form class=vl-top-form aria-label="navigate site"><label class=vl-sr-only for=vl-top-select>navigate to page</label>
<select id=vl-top-select class=vl-top-select onchange="const option=this.options[this.selectedIndex];if(option&&!option.disabled){const e=option.value;e&&(window.location.href=e)}"><option value=placeholder disabled>navigate...</option><option value=/>home</option><option value=/blog/ selected>mathematics blog</option><option value=/log/>log</option><option value=/cv/>curriculum vitae</option><option value=separator-4 disabled>..................................................</option><option value=/contact/>contact</option><option value=https://github.com/eliasjudin>github</option><option value=https://za.linkedin.com/in/elias-judin-a6988325a>linkedin</option></select></form><nav class=vl-sr-only aria-label="Primary site navigation"><ul><li><a href=/>home</a></li><li><a href=/blog/ aria-current=page>mathematics blog</a></li><li><a href=/log/>log</a></li><li><a href=/cv/>curriculum vitae</a></li><li><a href=/contact/>contact</a></li><li><a href=https://github.com/eliasjudin>github</a></li><li><a href=https://za.linkedin.com/in/elias-judin-a6988325a>linkedin</a></li></ul></nav></div><div class=vl-top-title><a href=/ class=vl-top-title-link>Elias Judin</a></div></div><div id=vl-tickers class=vl-tickers role=presentation><div class=vl-ticker data-speed=medium><div class=vl-ticker-label aria-hidden=true>about</div><div class=vl-ticker-marquee><span class=vl-sr-only>about: Mathematician & AI engineer, category theory, universal algebra, topology & sheaf theory, formal verification, foundation-model infrastructure</span><div class=vl-ticker-track aria-hidden=true>&nbsp;: Mathematician & AI engineer : category theory : universal algebra : topology & sheaf theory : formal verification : foundation-model infrastructure :&nbsp;&nbsp;&nbsp;&nbsp;</div></div></div><div class=vl-ticker data-speed=fast><div class=vl-ticker-label aria-hidden=true>now</div><div class=vl-ticker-marquee><span class=vl-sr-only>now: may 2025 — Lean4 formalization (part-time), march 2025 — AMC/AIME Lean4 labeling, august 2024 — Weekly category seminars, march 2024 — Research grant 2024</span><div class=vl-ticker-track aria-hidden=true>&nbsp;:: may 2025 — Lean4 formalization (part-time) :: march 2025 — AMC/AIME Lean4 labeling :: august 2024 — Weekly category seminars :: march 2024 — Research grant 2024 ::&nbsp;&nbsp;&nbsp;&nbsp;</div></div></div><div class=vl-ticker data-speed=slow><div class=vl-ticker-label aria-hidden=true>affiliations</div><div class=vl-ticker-marquee><span class=vl-sr-only>affiliations: Harmonic, Project Numina, University of Cape Town, University of the Witwatersrand, Kili Technology, Lean Prover community, SAOTA</span><div class=vl-ticker-track aria-hidden=true>&nbsp;::: Harmonic ::: Project Numina ::: University of Cape Town ::: University of the Witwatersrand ::: Kili Technology ::: Lean Prover community ::: SAOTA :::&nbsp;&nbsp;&nbsp;&nbsp;</div></div></div></div></header><main id=main class=vl-main><div class="vl-section vl-section--post"><article class="vl-section-inner h-entry"><nav class=vl-breadcrumbs aria-label=Breadcrumb><ol class=vl-breadcrumbs-list><li class=vl-breadcrumbs-item><a href=https://eliasjudin.github.io/>Elias Judin</a></li><li class=vl-breadcrumbs-item><a href=https://eliasjudin.github.io/blog/>Blog</a></li><li class=vl-breadcrumbs-item><span aria-current=page>Modules and Vector Spaces as Algebraic Categories</span></li></ol></nav><header class=vl-section-header><h1 class="vl-section-heading p-name">Modules and Vector Spaces as Algebraic Categories</h1><p class=vl-section-meta><time class=dt-published datetime=2022-06-26>26 Jun 2022</time></p><p class=vl-section-meta><time class=dt-updated datetime=2025-12-24>Updated 24 Dec 2025</time></p></header><div class="vl-section-body vl-single e-content"><p>An algebraic category is defined to be any full subcategory of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">Alg</mtext><mo stretchy="false">(</mo><mi mathvariant="normal">Ω</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\textbf{Alg}(\Omega)</annotation></semantics></math>, the category of all <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math>-algebras. We can define various algebraic structures as algebraic categories. For example, in order to define <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">Groups</mtext></mrow><annotation encoding="application/x-tex">\textbf{Groups}</annotation></semantics></math>, the category of Groups, we can specify <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi><mo>=</mo><mspace linebreak="newline"></mspace><mrow><mi>e</mi><mo separator="true">,</mo><mi>m</mi><mo separator="true">,</mo><mi>i</mi><mspace linebreak="newline"></mspace></mrow></mrow><annotation encoding="application/x-tex">\Omega = \\{e,m,i\\}</annotation></semantics></math> as the set consisting of three operators: one nullary, one unary, and one binary, such that, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mi>e</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(G,e,m)</annotation></semantics></math> is a monoid and</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mo>=</mo><mi>m</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(i(x),x)=x=m(x,(i(x))</annotation></semantics></math><p><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo>∈</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">\forall x \in G</annotation></semantics></math>, making <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">Alg</mtext><mo stretchy="false">(</mo><mi mathvariant="normal">Ω</mi><mo stretchy="false">)</mo><mo>=</mo><mtext mathvariant="bold">Groups</mtext></mrow><annotation encoding="application/x-tex">\textbf{Alg}(\Omega) = \textbf{Groups}</annotation></semantics></math> for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math> as specified<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. However, an issue arises when considering vector spaces over a field and modules over a ring as the operators in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math> are defined to act on the elements of the underlying set, and not on elements outside of that set, say in a field or a ring. This issue arises when trying to define scalar multiplication for these structures. Consider a vector space <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> over a field <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math>. We define a binary operator <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math> on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> called multiplication, then <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>:</mo><msup><mi>V</mi><mn>2</mn></msup><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v(m):V^2\to V</annotation></semantics></math>, where</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>v</mi><mo>:</mo><mi mathvariant="normal">Ω</mi><mo>→</mo><munder><mo>⋃</mo><mrow><mi>n</mi><mo>∈</mo><mi mathvariant="bold">N</mi></mrow></munder><msup><mi>V</mi><msup><mi>V</mi><mi>n</mi></msup></msup></mrow><annotation encoding="application/x-tex">v: \Omega \to \bigcup_{n \in \mathbf{N}} V^{V^{n}}</annotation></semantics></math><p>for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">N</mi></mrow><annotation encoding="application/x-tex">\mathbf{N}</annotation></semantics></math> the natural numbers<sup id=fnref1:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. Now there is an issue since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math> is not defined to operate on the elements of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math>. What follows is an explanation as to how we can get around this issue and define vector spaces over a field <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math> and modules over a ring <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math> as algebraic categories.</p><hr><p>We start with <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math>-modules. Let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math> be a commutative ring with <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> the underlying set of the module. Define the signature <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>M</mi></msub><mo>=</mo><mspace linebreak="newline"></mspace><mrow><msub><mi>a</mi><mi>M</mi></msub><mo separator="true">,</mo><msub><mn>0</mn><mi>M</mi></msub><mo separator="true">,</mo><msub><mi>i</mi><mi>M</mi></msub><mspace linebreak="newline"></mspace></mrow></mrow><annotation encoding="application/x-tex">\Omega_M = \\{a_M,0_M,i_M\\}</annotation></semantics></math> where <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">a_M</annotation></semantics></math> is a commutative associative binary operator on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mn>0</mn><mi>M</mi></msub><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">0_M\in M</annotation></semantics></math> is a nullary operator such that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>a</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><msub><mn>0</mn><mi>M</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>u</mi><mo>=</mo><msub><mi>a</mi><mi>M</mi></msub><mo stretchy="false">(</mo><msub><mn>0</mn><mi>M</mi></msub><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a_M(u,0_M)=u=a_M(0_M,u)</annotation></semantics></math><p><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>u</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\forall u\in M</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">i_M</annotation></semantics></math> is an unary operator on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> such that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>a</mi><mi>M</mi></msub><mo stretchy="false">(</mo><msub><mi>i</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mn>0</mn><mi>M</mi></msub><mo>=</mo><msub><mi>a</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><msub><mi>i</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a_M(i_M(u),u)=0_M=a_M(u,i_M(u))</annotation></semantics></math><p><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>u</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\forall u\in M</annotation></semantics></math>.
Now, in order to define scalar multiplication, we define the signature <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>R</mi></msub><mo>=</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">\Omega_R = R</annotation></semantics></math> where each element of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math> is considered as a unary operator on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>. However, we need to add some structure to <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">\Omega_R</annotation></semantics></math> since, in a ring, we are able to add and multiply elements of the ring to get new elements in the ring. To do this, we define a signature for an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math>-algebra on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">\Omega_R</annotation></semantics></math> by <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="normal">Ω</mi><mi>R</mi><mtext>ring</mtext></msubsup><mo>=</mo><mspace linebreak="newline"></mspace><mrow><mi>a</mi><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mi>i</mi><mo separator="true">,</mo><mi>m</mi><mo separator="true">,</mo><mn>1</mn><mspace linebreak="newline"></mspace></mrow></mrow><annotation encoding="application/x-tex">\Omega_{R}^{\text{ring}} = \\{a,0,i,m,1\\}</annotation></semantics></math> with the same properties as the operators in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">\Omega_M</annotation></semantics></math> above for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">a,0,i</annotation></semantics></math> and additionally, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math> is an associative binary operator on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">\Omega_R</annotation></semantics></math> such that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(r,a(s,t)) = a(m(r,s),m(r,t))</annotation></semantics></math><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(a(r,s),t) = a(m(r,t),m(s,t))</annotation></semantics></math><p><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>r</mi><mo separator="true">,</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo>∈</mo><msub><mi mathvariant="normal">Ω</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">\forall r,s,t\in \Omega_R</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∈</mo><msub><mi mathvariant="normal">Ω</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">1\in \Omega_R</annotation></semantics></math> is a nullary operator such that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>r</mi><mo>=</mo><mi>m</mi><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(r,1)=r=m(1,r)</annotation></semantics></math><p><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>r</mi><mo>∈</mo><msub><mi mathvariant="normal">Ω</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">\forall r\in \Omega_R</annotation></semantics></math>. We can then make <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><msub><mi>h</mi><mi>M</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M=(M,h_M)</annotation></semantics></math> into an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">\Omega_R</annotation></semantics></math>-set (as in Example 3.10) by defining the map <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>M</mi></msub><mo>:</mo><msub><mi mathvariant="normal">Ω</mi><mi>R</mi></msub><mo>×</mo><mi>M</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">h_M:\Omega_R\times M\to M</annotation></semantics></math> as <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mi>ω</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">h_M(\omega,p)=\omega p</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>p</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\forall p \in M</annotation></semantics></math> <sup id=fnref2:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. However, we require additional properties for the map <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">h_M</annotation></semantics></math>:</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>h</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><mi>u</mi></mrow><annotation encoding="application/x-tex">h_M(1,u)=u</annotation></semantics></math><p></p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>h</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mi>a</mi><mi>M</mi></msub><mo stretchy="false">(</mo><msub><mi>h</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>h</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_M(\omega,a_M(u,v)) = a_M(h_M(\omega,u),h_M(\omega,v))</annotation></semantics></math><p></p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>h</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><msup><mi>ω</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>a</mi><mi>M</mi></msub><mo stretchy="false">(</mo><msub><mi>h</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>h</mi><mi>M</mi></msub><mo stretchy="false">(</mo><msup><mi>ω</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_M(a(\omega,\omega^{\prime}),u)=a_M(h_M(\omega,u),h_M(\omega^{\prime},u))</annotation></semantics></math><p></p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>h</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><msup><mi>ω</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>h</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><msub><mi>h</mi><mi>M</mi></msub><mo stretchy="false">(</mo><msup><mi>ω</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_M(m(\omega,\omega^{\prime}),u)=h_M(\omega , h_M(\omega^{\prime},u))</annotation></semantics></math><p><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>ω</mi><mo separator="true">,</mo><msup><mi>ω</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∈</mo><msub><mi mathvariant="normal">Ω</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">\forall \omega,\omega^{\prime}\in\Omega_R</annotation></semantics></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\forall u,v\in M</annotation></semantics></math>. In this way, scalar multiplication of an element of M by one of R is defined using the map <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">h_M</annotation></semantics></math>. So by letting the signature of the <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math>-module be <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi><mo>=</mo><msub><mi mathvariant="normal">Ω</mi><mi>R</mi></msub><mo>∪</mo><msub><mi mathvariant="normal">Ω</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">\Omega = \Omega_R \cup \Omega_ M</annotation></semantics></math>, we obtain <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">Alg</mtext><mo stretchy="false">(</mo><mi mathvariant="normal">Ω</mi><mo stretchy="false">)</mo><mo>=</mo><mtext mathvariant="bold">Modules</mtext></mrow><annotation encoding="application/x-tex">\textbf{Alg}(\Omega)=\textbf{Modules}</annotation></semantics></math>, showing <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">Modules</mtext></mrow><annotation encoding="application/x-tex">\textbf{Modules}</annotation></semantics></math> is an algebraic category.</p><hr><p>Similarly, for a vector space <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> over a field <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math> we can define a signature <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>V</mi></msub><mo>=</mo><mspace linebreak="newline"></mspace><mrow><msub><mi>a</mi><mi>V</mi></msub><mo separator="true">,</mo><msub><mn>0</mn><mi>V</mi></msub><mo separator="true">,</mo><msub><mi>i</mi><mi>V</mi></msub><mspace linebreak="newline"></mspace></mrow></mrow><annotation encoding="application/x-tex">\Omega_V = \\{a_V,0_V,i_V\\}</annotation></semantics></math> where <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>V</mi></msub></mrow><annotation encoding="application/x-tex">a_V</annotation></semantics></math> is a commutative associative binary operator on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mn>0</mn><mi>V</mi></msub><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">0_V\in V</annotation></semantics></math> is a nullary operator such that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>a</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><msub><mn>0</mn><mi>V</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>u</mi><mo>=</mo><msub><mi>a</mi><mi>V</mi></msub><mo stretchy="false">(</mo><msub><mn>0</mn><mi>V</mi></msub><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a_V(u,0_V)=u=a_V(0_V,u)</annotation></semantics></math><p><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>u</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\forall u\in V</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mi>V</mi></msub></mrow><annotation encoding="application/x-tex">i_V</annotation></semantics></math> is an unary operator on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> such that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>a</mi><mi>V</mi></msub><mo stretchy="false">(</mo><msub><mi>i</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mo>=</mo><msub><mi>a</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><msub><mi>i</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a_V(i_V(u),u)=0=a_V(u,i_V(u))</annotation></semantics></math><p><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>u</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\forall u\in V</annotation></semantics></math>.
To define scalar multiplication of elements of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> by those of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math>, we define the signature <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>K</mi></msub><mo>=</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">\Omega_K = K</annotation></semantics></math> in which each element of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math> is a unary operator on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>. We add a field structure to <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">\Omega_K</annotation></semantics></math> by defining a signature for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">\Omega_K</annotation></semantics></math> as <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="normal">Ω</mi><mi>K</mi><mtext>field</mtext></msubsup><mo>=</mo><mspace linebreak="newline"></mspace><mrow><mi>a</mi><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>i</mi><mi>a</mi></msub><mo separator="true">,</mo><mi>m</mi><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>i</mi><mi>m</mi></msub><mspace linebreak="newline"></mspace></mrow></mrow><annotation encoding="application/x-tex">\Omega_{K}^{\text{field}}=\\{a,0,i_a,m,1,i_m\\}</annotation></semantics></math> with the same properties as the operators in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>V</mi></msub></mrow><annotation encoding="application/x-tex">\Omega_V</annotation></semantics></math> above for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">a,0,i</annotation></semantics></math> and additionally, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math> is a commutative associative binary operator on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">\Omega_K</annotation></semantics></math> such that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">(</mo><mi>d</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(c,a(d,f)) = a(m(c,d),m(c,f))</annotation></semantics></math><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">(</mo><mi>d</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(a(c,d),f) = a(m(c,f),m(d,f))</annotation></semantics></math><p><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo separator="true">,</mo><mi>f</mi><mo>∈</mo><msub><mi mathvariant="normal">Ω</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">\forall c,d,f\in \Omega_K</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∈</mo><msub><mi mathvariant="normal">Ω</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">1\in \Omega_K</annotation></semantics></math> is a nullary operator such that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>c</mi><mo>=</mo><mi>m</mi><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(c,1)=c=m(1,c)</annotation></semantics></math><p><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>c</mi><mo>∈</mo><msub><mi mathvariant="normal">Ω</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">\forall c\in \Omega_K</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">i_m</annotation></semantics></math> is an unary operator on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">\Omega_K</annotation></semantics></math> such that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><msub><mi>i</mi><mi>m</mi></msub><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mo>=</mo><mi>m</mi><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><msub><mi>i</mi><mi>m</mi></msub><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(i_m(c),c)=0=m(c,i_m(c))</annotation></semantics></math><p><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>c</mi><mo>∈</mo><msub><mi mathvariant="normal">Ω</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">\forall c\in \Omega_K</annotation></semantics></math>. Next, make <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><msub><mi>h</mi><mi>V</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V=(V,h_V)</annotation></semantics></math> into an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">\Omega_K</annotation></semantics></math>-set by defining the map <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>V</mi></msub><mo>:</mo><msub><mi mathvariant="normal">Ω</mi><mi>K</mi></msub><mo>×</mo><mi>V</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">h_V:\Omega_K\times V\to V</annotation></semantics></math> as <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><mi>ω</mi><mi>u</mi></mrow><annotation encoding="application/x-tex">h_V(\omega,u)=\omega u</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>u</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\forall u \in V</annotation></semantics></math> with the additional properties that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>h</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mi>a</mi><mi>V</mi></msub><mo stretchy="false">(</mo><msub><mi>h</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>h</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_V(\omega,a_V(u,q))=a_V(h_V(\omega ,u), h_V(\omega ,q))</annotation></semantics></math><p></p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>h</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><msup><mi>ω</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>a</mi><mi>V</mi></msub><mo stretchy="false">(</mo><msub><mi>h</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>h</mi><mi>V</mi></msub><mo stretchy="false">(</mo><msup><mi>ω</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_V(a(\omega,\omega^{\prime}),u) = a_V(h_V(\omega ,u), h_V(\omega^{\prime},u))</annotation></semantics></math><p></p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>h</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><msup><mi>ω</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>h</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><msub><mi>h</mi><mi>V</mi></msub><mo stretchy="false">(</mo><msup><mi>ω</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_V(m(\omega,\omega^{\prime}),u) = h_V(\omega ,h_V(\omega^{\prime},u))</annotation></semantics></math><p></p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>h</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><mi>u</mi></mrow><annotation encoding="application/x-tex">h_V(1,u) = u</annotation></semantics></math><p><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>ω</mi><mo separator="true">,</mo><msup><mi>ω</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∈</mo><msub><mi mathvariant="normal">Ω</mi><mi>K</mi></msub><mtext>  </mtext><mi mathvariant="normal">∀</mi><mi>u</mi><mo separator="true">,</mo><mi>q</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\forall \omega,\omega^{\prime}\in\Omega_K\;\forall u,q\in V</annotation></semantics></math>. So, for the signature <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi><mo>=</mo><msub><mi mathvariant="normal">Ω</mi><mi>V</mi></msub><mo>∪</mo><msub><mi mathvariant="normal">Ω</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">\Omega = \Omega_ V\cup\Omega_ K</annotation></semantics></math>, we obtain <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">Alg</mtext><mo stretchy="false">(</mo><mi mathvariant="normal">Ω</mi><mo stretchy="false">)</mo><mo>=</mo><mtext mathvariant="bold">Vect</mtext></mrow><annotation encoding="application/x-tex">\textbf{Alg}(\Omega)=\textbf{Vect}</annotation></semantics></math>, showing that the category of vector spaces is an algebraic category.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>George Janelidze, <em>Category theory: A first course</em>, 2020.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref2:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div><footer class=vl-single-footer><p class="vl-section-meta vl-single-tags"><span class=vl-single-tags-label>Tags:</span>
<a class=p-category href=/tags/category-theory/ rel=tag>Category theory</a>, <a class=p-category href=/tags/universal-algebra/ rel=tag>Universal algebra</a></p></footer></div></article></div></main><footer class=vl-footer role=contentinfo><div class=vl-footer-note>© 2025 by Elias Judin</div></footer></div></div></body></html>