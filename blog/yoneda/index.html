<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>M-sets and Yoneda for monoids — Elias Judin</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Exercises in category theory: M-sets and the Yoneda lemma for monoids"><meta name=robots content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=theme-color content="#ffffff"><meta name=author content="Elias Judin"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><link rel=canonical href=https://eliasjudin.github.io/blog/yoneda/><meta property="og:url" content="https://eliasjudin.github.io/blog/yoneda/"><meta property="og:title" content="M-sets and Yoneda for monoids — Elias Judin"><meta property="og:description" content="Exercises in category theory: M-sets and the Yoneda lemma for monoids"><meta property="og:type" content="article"><meta property="og:site_name" content="Elias Judin"><meta property="og:image" content="https://eliasjudin.github.io/assets/images/banner-social.png"><meta property="og:image:alt" content="M-sets and Yoneda for monoids — Elias Judin"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="M-sets and Yoneda for monoids — Elias Judin"><meta name=twitter:description content="Exercises in category theory: M-sets and the Yoneda lemma for monoids"><meta name=twitter:image content="https://eliasjudin.github.io/assets/images/banner-social.png"><meta name=twitter:image:alt content="M-sets and Yoneda for monoids — Elias Judin"><link rel=alternate type=application/rss+xml title="Elias Judin" href=https://eliasjudin.github.io/index.xml><meta property="article:published_time" content="2022-07-15T10:51:26+04:00"><meta property="article:modified_time" content="2022-07-15T10:51:26+04:00"><link rel=icon type=image/svg+xml href=/favicon.svg><style>:root{color-scheme:light;--vl-link-color:#0000ee;--vl-link-hover-color:#0000cc;--vl-link-visited-color:#551a8b;--vl-link-underline-color:var(--vl-link-color);--vl-link-visited-underline-color:var(--vl-link-visited-color);--vl-link-underline-offset:2px;--vl-link-underline-thickness:1px}*,*::before,*::after{box-sizing:border-box}html{background:#fff;color:#000;font-size:10px}body{margin:0;background:#fff;color:inherit;font-family:Arial,Helvetica,sans-serif;line-height:1.5;text-align:center}math{font-family:stix two math,cambria math,latin modern math,noto serif math,serif;font-size:1em;line-height:1.3;math-style:normal;math-depth:add(0)}math[display=block]{display:block;margin:14px auto;text-align:center;overflow-x:auto;padding:2px 0}math[display=block]>*{margin-left:auto;margin-right:auto}math semantics annotation,math semantics annotation-xml,math annotation,math annotation-xml{display:none}math mo{vertical-align:baseline}math mover,math munder,math munderover{vertical-align:middle}math[display=inline]{vertical-align:-.25ex}.vl-skip-link{position:absolute;left:16px;top:-40px;padding:6px 12px;background:#fff;color:#000;border:1px solid #000;font-size:12px;text-decoration:none;z-index:1000}.vl-skip-link:focus,.vl-skip-link:focus-visible{top:16px}a{color:var(--vl-link-color);text-decoration-line:underline;text-decoration-color:var(--vl-link-underline-color);text-decoration-thickness:var(--vl-link-underline-thickness);text-underline-offset:var(--vl-link-underline-offset);text-decoration-skip-ink:auto}a:visited{color:var(--vl-link-visited-color);text-decoration-color:var(--vl-link-visited-underline-color)}a:hover,a:focus{color:var(--vl-link-hover-color);background:0 0}a:focus-visible,select:focus-visible,button:focus-visible{outline:1px dotted #000;outline-offset:2px}img{border:0;max-width:100%;height:auto}.vl-page{width:100%;min-height:100vh;display:flex;justify-content:center;background:#fff}.vl-frame{width:800px;display:flex;flex-direction:column;align-items:stretch;min-height:100vh}.vl-header{position:sticky;top:0;z-index:10;background:#fff}.vl-top{display:flex;align-items:flex-end;justify-content:space-between;height:80px;padding-bottom:8px;background:#fff}.vl-top-form{margin:0}.vl-top-select{min-width:260px;font-size:10px;font-family:inherit;color:inherit;background:#fff;border:1px solid #000;padding:2px 4px}.vl-top-title{font-size:36px;letter-spacing:.5px}.vl-top-title-link{color:inherit;text-decoration:none}.vl-top-title-link:visited{color:inherit;text-decoration:none}.vl-top-title-link:focus,.vl-top-title-link:focus-visible,.vl-top-title-link:hover{color:inherit;text-decoration:none;background:0 0}.vl-tickers{display:grid;grid-template-rows:repeat(auto-fit,15px)}.vl-ticker{height:15px;overflow:hidden;background:#fff;font-size:10px;line-height:15px;border-top:1px solid #fff}.vl-ticker-track{display:inline-block;white-space:nowrap;padding-left:100%}.vl-ticker[data-speed=medium] .vl-ticker-track{animation:tickerMedium 30s linear infinite}.vl-ticker[data-speed=fast] .vl-ticker-track{animation:tickerFast 20s linear infinite}.vl-ticker[data-speed=slow] .vl-ticker-track{animation:tickerSlow 300s linear infinite}.vl-ticker[data-speed=very-slow] .vl-ticker-track{animation:tickerVerySlow 420s linear infinite}@keyframes tickerMedium{0%{transform:translateX(0)}10%{transform:translateX(0)}100%{transform:translateX(-100%)}}@keyframes tickerFast{0%{transform:translateX(0)}20%{transform:translateX(0)}100%{transform:translateX(-100%)}}@keyframes tickerSlow{0%{transform:translateX(0)}0.17%{transform:translateX(0)}100%{transform:translateX(-100%)}}@keyframes tickerVerySlow{0%{transform:translateX(0)}0.1%{transform:translateX(0)}100%{transform:translateX(-100%)}}.vl-main{flex:auto;display:flex;flex-direction:column;align-items:stretch;padding-bottom:40px}.vl-home-wrapper{padding-top:20px}.vl-home-table-scroll{margin:0 auto;max-width:100%;display:flex;justify-content:center;overflow:hidden;--vl-home-width:800px;--vl-home-width:clamp(160px, calc(100vw - 32px), 800px)}.vl-home-table-scroll:focus-visible{outline:1px dotted #000;outline-offset:4px}.vl-home-table{margin:0 auto;border-collapse:collapse;width:var(--vl-home-width);min-width:0}.vl-home-table td{font-size:10px;padding:0;line-height:0}.vl-home-table td font{display:block;line-height:0}.vl-home-table td img{display:block;width:calc(var(--vl-home-width)/(800/11));height:calc(var(--vl-home-width)/(800/11));image-rendering:pixelated}.vl-home-scatter{position:relative;display:block;margin:0 auto;pointer-events:none}.vl-home-scatter__dot{position:absolute;display:block;width:11px;height:11px}.vl-home-scatter--projects{width:70px;height:46px}.vl-home-scatter--log{width:90px;height:68px}.vl-home-panels{width:100%;max-width:800px;margin:24px auto 0;display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:24px;text-align:left;font-size:10px}.vl-home-panel{font-size:inherit}.vl-home-panel h2{font-size:12px;margin:0 0 8px;letter-spacing:.5px}.vl-home-panel ul{list-style:none;padding:0;margin:0}.vl-home-panel li{margin-bottom:6px}.vl-home-panel time,.vl-home-panel-date{font-style:italic;margin-right:4px}.vl-home-latest{text-align:left}.vl-home-panel-date{display:inline}.vl-home-content{width:800px;margin:32px auto 0;text-align:left}.vl-home-content>:first-child{margin-top:0}.vl-home-content p,.vl-home-content li{font-size:10px}.vl-home-content h2{font-size:14px;margin:18px 0 8px}.vl-home-content h3{font-size:12px;margin:16px 0 6px}.vl-timeline{list-style:none;padding:0;margin:12px 0 0;display:grid;gap:6px}.vl-timeline li{display:flex;align-items:baseline;gap:8px}.vl-timeline-date{font-weight:700;text-transform:uppercase;letter-spacing:.5px;min-width:120px}.vl-home-panel--milestones{line-height:1.6}.vl-home-panel--milestones strong,.vl-home-panel--milestones b{font-weight:400}.vl-home-panel-list{list-style:none;padding:0;margin:0}.vl-home-panel-list li{margin-bottom:6px}.vl-home-panel-list li:last-child{margin-bottom:0}.vl-home-panel-item{display:block}.vl-home-panel-list[data-enhanced=true] .vl-home-panel-item{display:none}.vl-home-panel-list[data-enhanced=true] .vl-home-panel-item.is-visible{display:block}.vl-home-panel-list{position:relative}.vl-home-panel-list.is-animating[data-direction=forward]{animation:vl-home-slide-forward 320ms ease-out}.vl-home-panel-list.is-animating[data-direction=reset]{animation:vl-home-slide-reset 320ms ease-out}@keyframes vl-home-slide-forward{0%{transform:translateX(32px);opacity:0}100%{transform:translateX(0);opacity:1}}@keyframes vl-home-slide-reset{0%{transform:translateX(16px);opacity:0}100%{transform:translateX(0);opacity:1}}@media(prefers-reduced-motion:reduce){.vl-home-panel-list.is-animating{animation:none}}.vl-home-panel-more{margin-top:6px;display:inline-block;font-size:10px;font-style:italic;letter-spacing:.3px;color:#000;text-decoration:none;cursor:pointer;background:0 0;border:0;padding:0;font-family:inherit}.vl-home-panel-more:hover,.vl-home-panel-more:focus{text-decoration:underline}.vl-home-panel-more:focus-visible{outline:1px dotted #000;outline-offset:2px}.vl-section-subheading{margin:0;font-size:10px;font-weight:400;letter-spacing:.4px;max-width:420px}.vl-section-header--stacked{flex-direction:column;align-items:flex-start;gap:6px}.vl-breadcrumbs{text-align:left;font-size:10px;letter-spacing:.4px}.vl-breadcrumbs-list{display:flex;flex-wrap:wrap;align-items:center;gap:6px;margin:0;padding:0;list-style:none}.vl-breadcrumbs-item{display:flex;align-items:center;gap:6px}.vl-breadcrumbs-item+.vl-breadcrumbs-item::before{content:"/";display:inline-block;margin-right:6px}.vl-breadcrumbs a{color:inherit;text-decoration:none}.vl-breadcrumbs a:hover,.vl-breadcrumbs a:focus{text-decoration:underline}.vl-section--timeline .vl-section-body{font-size:12px;line-height:1.6;text-align:left}.vl-section-meta{margin:0;font-size:10px;letter-spacing:.4px}.vl-single{display:flex;flex-direction:column;gap:16px}.vl-single>*:first-child{margin-top:0}.vl-single h2,.vl-single h3,.vl-single h4{font-size:12px;margin:24px 0 8px;letter-spacing:.4px}.vl-single h2{text-transform:uppercase}.vl-single h3{margin-top:20px}.vl-single hr{border:0;border-top:1px solid #000;margin:24px 0}.vl-single blockquote{border-left:1px solid #000;margin:16px 0;padding:0 0 0 12px;font-style:italic}.vl-single figure,.vl-single img{margin:16px auto}.vl-single figure{display:flex;flex-direction:column;gap:8px;width:100%;max-width:100%}.vl-single figure img,.vl-single>img{display:block;max-width:100%;width:100%;height:auto}.vl-single figcaption{font-size:9px;text-transform:uppercase;letter-spacing:.6px}.vl-single table{width:100%;border-collapse:collapse;font-size:10px;margin:14px 0}.vl-single table caption{margin-bottom:6px;font-weight:700;text-align:left}.vl-single table thead th{text-transform:uppercase;letter-spacing:.4px;font-weight:700;border-bottom:1px solid rgba(0,0,0,.5);padding:6px 6px 8px}.vl-single table tbody tr{border-bottom:1px solid rgba(0,0,0,.18)}.vl-single table tbody tr:last-child{border-bottom:none}.vl-single table th,.vl-single table td{padding:6px;text-align:left;vertical-align:top}.vl-single ul,.vl-single ol{padding-left:20px;margin:0}.vl-single li{margin:0 0 8px}.vl-single p>img,.vl-single li>img{display:block;margin:16px auto;max-width:min(100%,560px)}.vl-list-meta{margin:4px 0 0;font-size:10px;letter-spacing:.4px}.vl-timeline-body .vl-timeline{margin-top:8px;padding-left:0;gap:14px}.vl-timeline-body .vl-timeline li{position:relative;padding-left:24px;align-items:flex-start;gap:16px}.vl-timeline-body .vl-timeline li::before,.vl-timeline-body .vl-timeline li::after{content:"";position:absolute;left:0}.vl-timeline-body .vl-timeline li::before{top:.6em;width:10px;height:10px;border:1px solid #000;background:#fff;transform:translate(-50%,-50%)}.vl-timeline-body .vl-timeline li::after{top:.6em;width:1px;height:calc(100% + 10px);background:#000;transform:translateX(-50%)}.vl-timeline-body .vl-timeline li:last-child::after{display:none}.vl-section--timeline .vl-timeline-date{font-size:12px;min-width:140px;letter-spacing:.6px}.vl-section{width:800px;margin:0 auto}.vl-section-inner{display:flex;flex-direction:column;gap:18px;padding:50px 10px 10px}.vl-section-header{display:flex;align-items:flex-end;justify-content:space-between}.vl-section table{width:100%;border-collapse:collapse}.vl-section-heading{font-size:10px;font-weight:700;text-align:left}.vl-section-body{text-align:left;font-size:10px}.vl-section-body p{margin:0 0 12px}.vl-list-entry{margin-bottom:18px}.vl-list-entry h2{font-size:14px;margin:0 0 4px;font-weight:700}.vl-list-entry time{display:block;margin-bottom:6px}.vl-pagination{margin-top:20px;font-size:10px}.vl-pagination a{margin:0 6px}.vl-sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.vl-single{text-align:left;font-size:10px;max-width:640px;margin:0 auto}.vl-single h1,.vl-single h2,.vl-single h3,.vl-single h4,.vl-single h5,.vl-single h6{font-weight:700;letter-spacing:.3px}.vl-single h1{font-size:18px;margin:0 0 12px}.vl-single h2{font-size:14px;margin:18px 0 8px}.vl-single h3{font-size:12px;margin:16px 0 6px}.vl-single p,.vl-single li{font-size:10px}.vl-single blockquote{margin:12px 0;padding-left:12px;border-left:1px solid #000;font-style:italic}.vl-single>*{margin-left:auto;margin-right:auto}.vl-single p,.vl-single ul,.vl-single ol,.vl-single blockquote,.vl-single pre,.vl-single table,.vl-single figure,.vl-single hr,.vl-single math[display=block]{max-width:100%}.vl-single ul,.vl-single ol{padding-left:20px;margin:12px 0}.vl-single li+li{margin-top:6px}.vl-single time{font-style:italic;color:#333}.vl-single hr{border:0;border-top:1px solid #000;margin:24px 0}.vl-single table{border-collapse:collapse;margin:16px 0;font-size:10px}.vl-single table caption{margin-bottom:6px;font-weight:700;text-align:left}.vl-single table thead th{text-transform:uppercase;letter-spacing:.4px;font-weight:700;border-bottom:1px solid rgba(0,0,0,.5);padding:6px 6px 8px}.vl-single table tbody tr{border-bottom:1px solid rgba(0,0,0,.18)}.vl-single table tbody tr:last-child{border-bottom:none}.vl-single table th,.vl-single table td{border:none;padding:6px;vertical-align:top;text-align:left}.vl-single p>img,.vl-single p>a>img{display:block;margin:24px auto;max-width:min(100%,520px)}.vl-section--cv .vl-section-inner{border:1px solid rgba(0,0,0,.42);background:#fff;padding:44px 40px 52px;gap:30px;box-shadow:12px 12px rgba(0,0,0,5%)}.vl-section--cv .vl-single{max-width:600px;margin:0;gap:18px;font-size:9.5px;line-height:1.6}.vl-section--cv .vl-single h1{font-size:13px;text-transform:uppercase;letter-spacing:.45px;margin:0}.vl-section--cv .vl-single h2{font-size:11px;text-transform:uppercase;letter-spacing:.4px;margin:26px 0 6px;border-top:1px solid rgba(0,0,0,.4);padding-top:14px}.vl-section--cv .vl-single h2:first-of-type{border-top:none;padding-top:0;margin-top:12px}.vl-section--cv .vl-single h3{font-size:10px;letter-spacing:.3px;margin:16px 0 6px}.vl-section--cv .vl-single p{margin:6px 0}.vl-section--cv .vl-single p:first-child{font-size:9px;letter-spacing:.5px;text-transform:uppercase;color:#444;margin-bottom:12px}.vl-section--cv .vl-single p:first-child em{font-style:normal}.vl-section--cv .vl-single p>strong:first-child{display:inline-block;min-width:160px;letter-spacing:.4px}.vl-section--cv .vl-single hr{border:0;border-top:1px solid rgba(0,0,0,.35);margin:18px 0 12px}.vl-section--cv .vl-single ul,.vl-section--cv .vl-single ol{margin:8px 0;padding-left:18px}.vl-section--cv .vl-single li{margin-bottom:6px}.vl-section--cv .vl-single table{border:none;font-size:9px;margin:8px 0 14px;width:100%}.vl-section--cv .vl-single table tr{border-bottom:1px solid rgba(0,0,0,.25)}.vl-section--cv .vl-single table tr:last-child{border-bottom:none}.vl-section--cv .vl-single table th,.vl-section--cv .vl-single table td{border:none;padding:4px 0;vertical-align:top}.vl-section--cv .vl-single table th{text-transform:uppercase;letter-spacing:.35px}@media(max-width:720px){.vl-section--cv .vl-section-inner{padding:32px 22px 42px;box-shadow:8px 8px rgba(0,0,0,5%)}.vl-section--cv .vl-single{max-width:100%}.vl-section--cv .vl-single p>strong:first-child{min-width:120px}}@media(max-width:680px){.vl-single{max-width:none}.vl-single table{display:block;width:100%;overflow-x:auto;-webkit-overflow-scrolling:touch}}.pdf-container{margin:32px 0;font-size:12px;color:inherit;outline:none}.pdf-container:focus-visible{outline:1px dashed currentColor;outline-offset:4px}.pdf-header{display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:8px 16px;margin-bottom:8px}.pdf-title{font-weight:600;letter-spacing:.2px;flex:auto}.pdf-controls{display:inline-flex;align-items:center;gap:8px;flex-wrap:wrap}.pdf-button{background:0 0;border:1px solid transparent;padding:4px 6px;font:inherit;color:inherit;text-transform:lowercase;cursor:pointer;min-width:44px;min-height:32px;line-height:1}.pdf-button:hover:not(:disabled),.pdf-button:focus-visible{border-color:transparent}.pdf-button:disabled{opacity:.35;cursor:default}.page-counter{display:inline-flex;align-items:center;gap:2px}.page-total{display:none}.pdf-loading{margin-bottom:8px;font-style:italic}.pdf-loading.is-error{font-style:normal;color:#b00020}.pdf-viewer canvas{width:100%;border:1px solid #000;border-radius:0;display:block;background:#fff;min-height:320px}.pdf-footer{margin-top:8px;display:flex;flex-wrap:wrap;gap:8px 16px}.pdf-footer a{font-weight:500;text-decoration:underline}.pdf-open-link{text-transform:lowercase}@media(max-width:860px){.pdf-container{font-size:13px}.pdf-controls{gap:6px}}@media(max-width:680px){.pdf-container{margin:24px 0;font-size:13px}.pdf-header{flex-direction:column;align-items:flex-start;gap:6px}.pdf-controls{width:100%;justify-content:flex-start}.pdf-button{padding:6px 8px;min-height:36px}.pdf-footer{flex-direction:column;align-items:flex-start;gap:4px}.pdf-viewer canvas{min-height:240px}}.vl-footer-ticker{margin-top:auto;width:800px;margin-left:auto;margin-right:auto}.vl-footer-note{font-size:10px;text-align:left;margin:12px 0}@media(max-width:820px){body{text-align:left}.vl-page{justify-content:flex-start}.vl-frame{width:100%}.vl-footer-ticker,.vl-home-panels,.vl-home-latest,.vl-home-content,.vl-section,.vl-top,.vl-ticker,.vl-main{width:100%}.vl-home-panels{margin:24px 0 0;grid-template-columns:1fr;gap:16px}.vl-home-panel{font-size:11px}.vl-home-panel-more{font-size:11px;width:fit-content}.vl-top{flex-direction:column;align-items:flex-start;padding:16px 16px 8px;height:auto;gap:12px}.vl-top-select{min-width:auto}.vl-tickers{width:100%}.vl-main,.vl-footer-ticker{padding-left:16px;padding-right:16px}.vl-home-wrapper{padding-left:16px;padding-right:16px;margin-left:0;margin-right:0}.vl-section-inner{padding:32px 0 0}.vl-home-table-scroll{padding-left:0;padding-right:0;width:100%;justify-content:center;--vl-home-width:clamp(160px, calc(100vw - 64px), 800px)}.vl-home-latest,.vl-home-content,.vl-section{width:auto}.vl-home-content{margin-left:0;margin-right:0}.vl-timeline li{flex-direction:column;gap:2px}.vl-timeline-date{min-width:0}.vl-section--timeline .vl-section-body{font-size:11px}.vl-section--timeline .vl-timeline{gap:12px}.vl-section--timeline .vl-timeline li{padding-left:20px;gap:10px}.vl-section--timeline .vl-timeline li::after{height:calc(100% + 6px)}.vl-section--timeline .vl-section-subheading{max-width:100%}.vl-single{gap:14px}.vl-single figure,.vl-single figure img,.vl-single>img,.vl-single p>img{max-width:100%}.vl-single h2,.vl-single h3,.vl-single h4{margin-top:18px}}@media(max-width:680px){.vl-home-table-scroll{justify-content:flex-start;--vl-home-width:clamp(1200px, calc(100vw + 880px), 1600px);overflow-x:auto;overflow-y:hidden;-webkit-overflow-scrolling:touch}.vl-home-table{margin:0}}.vl-single math{font-size:1.05em}@media(prefers-reduced-motion:reduce){.vl-ticker-track{animation:none!important;padding-left:0;transform:none!important}}</style><link rel=preload href=/css/style.min.0dfca0129d6cf5948d497093f3f9bc36f493f458ccccce371315b56b8cb5f48a.css as=style integrity="sha256-DfygEp1s9ZSNSXCT8/m8NvST9FjMzM43ExW1a4y19Io="><noscript><link rel=stylesheet href=/css/style.min.0dfca0129d6cf5948d497093f3f9bc36f493f458ccccce371315b56b8cb5f48a.css integrity="sha256-DfygEp1s9ZSNSXCT8/m8NvST9FjMzM43ExW1a4y19Io="></noscript><script type=application/ld+json>[{"@context":"https://schema.org","@id":"https://eliasjudin.github.io/#website","@type":"WebSite","description":"Elias Judin's academic website and mathematics research blog on category theory, universal algebra, topology, and sheaf theory.","inLanguage":"en","name":"Elias Judin","publisher":{"@id":"https://eliasjudin.github.io/#person","@type":"Person","name":"Elias Judin","sameAs":["https://github.com/eliasjudin","https://za.linkedin.com/in/elias-judin-a6988325a"],"url":"https://eliasjudin.github.io/"},"url":"https://eliasjudin.github.io/"},{"@context":"https://schema.org","@id":"https://eliasjudin.github.io/blog/yoneda/#webpage","@type":"WebPage","description":"Exercises in category theory: M-sets and the Yoneda lemma for monoids","inLanguage":"en","isPartOf":{"@id":"https://eliasjudin.github.io/#website"},"name":"M-sets and Yoneda for monoids","primaryImageOfPage":{"@type":"ImageObject","url":"https://eliasjudin.github.io/assets/images/banner-social.png"},"url":"https://eliasjudin.github.io/blog/yoneda/"},{"@context":"https://schema.org","@id":"https://eliasjudin.github.io/blog/yoneda/#article","@type":"Article","author":[{"@type":"Person","name":"Elias Judin"}],"dateModified":"2022-07-15T10:51:26+04:00","datePublished":"2022-07-15T10:51:26+04:00","description":"Exercises in category theory: M-sets and the Yoneda lemma for monoids","headline":"M-sets and Yoneda for monoids","image":["https://eliasjudin.github.io/assets/images/banner-social.png"],"inLanguage":"en","isPartOf":{"@id":"https://eliasjudin.github.io/#website"},"keywords":"category-theory","mainEntityOfPage":{"@id":"https://eliasjudin.github.io/blog/yoneda/#webpage","@type":"WebPage"},"name":"M-sets and Yoneda for monoids","publisher":{"@id":"https://eliasjudin.github.io/#person","@type":"Person","name":"Elias Judin","sameAs":["https://github.com/eliasjudin","https://za.linkedin.com/in/elias-judin-a6988325a"],"url":"https://eliasjudin.github.io/"},"url":"https://eliasjudin.github.io/blog/yoneda/","wordCount":1141}]</script><meta name=generator content="Hugo 0.150.0"></head><body><a class=vl-skip-link href=#main>Skip to main content</a><div class=vl-page><div class=vl-frame><header class=vl-header role=banner><div class=vl-top><div><form class=vl-top-form aria-label="Navigate site"><label class=vl-sr-only for=vl-top-select>Navigate to page</label>
<select id=vl-top-select class=vl-top-select onchange="this.value&&(window.location.href=this.value)"><option value disabled>Navigate...</option><option value=/>home</option><option value=/blog selected>mathematics blog</option><option value=/log>latest notes</option><option value=/cv>curriculum vitae</option><option value disabled>..................................................</option><option value=/contact>contact</option><option value=https://github.com/eliasjudin>github</option><option value=https://za.linkedin.com/in/elias-judin-a6988325a>linkedin</option></select></form><nav class=vl-sr-only aria-label="Primary site navigation"><ul><li><a href=/>home</a></li><li><a href=/blog aria-current=page>mathematics blog</a></li><li><a href=/log>latest notes</a></li><li><a href=/cv>curriculum vitae</a></li><li><a href=/contact>contact</a></li><li><a href=https://github.com/eliasjudin>github</a></li><li><a href=https://za.linkedin.com/in/elias-judin-a6988325a>linkedin</a></li></ul></nav></div><div class=vl-top-title><a href=/ class=vl-top-title-link>Elias Judin</a></div></div><div class=vl-tickers role=presentation><div class=vl-ticker data-speed=medium><span class=vl-sr-only>Elias Judin, Category theory, Universal algebra</span><div class=vl-ticker-track aria-hidden=true>&nbsp;: Elias Judin : Category theory : Universal algebra :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: Elias Judin : Category theory : Universal algebra :&nbsp;&nbsp;&nbsp;&nbsp;</div></div><div class=vl-ticker data-speed=fast><span class=vl-sr-only>Lean4 @ Harmonic, Project Numina labeling, UCT category seminars, UCT grant 2024</span><div class=vl-ticker-track aria-hidden=true>&nbsp;:: Lean4 @ Harmonic :: Project Numina labeling :: UCT category seminars :: UCT grant 2024 ::&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: Lean4 @ Harmonic :: Project Numina labeling :: UCT category seminars :: UCT grant 2024 ::&nbsp;&nbsp;&nbsp;&nbsp;</div></div><div class=vl-ticker data-speed=slow><span class=vl-sr-only>University of Cape Town, Harmonic, Project Numina, Category Theory Group</span><div class=vl-ticker-track aria-hidden=true>&nbsp;::: University of Cape Town ::: Harmonic ::: Project Numina ::: Category Theory Group :::&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::: University of Cape Town ::: Harmonic ::: Project Numina ::: Category Theory Group :::&nbsp;&nbsp;&nbsp;&nbsp;</div></div></div></header><main id=main class=vl-main><div class="vl-section vl-section--post"><article class="vl-section-inner h-entry"><nav class=vl-breadcrumbs aria-label=Breadcrumb><ol class=vl-breadcrumbs-list><li class=vl-breadcrumbs-item><a href=/>Elias Judin</a></li><li class=vl-breadcrumbs-item><a href=/blog/>Blog</a></li><li class=vl-breadcrumbs-item><span aria-current=page>M-sets and Yoneda for monoids</span></li></ol></nav><header class=vl-section-header><h1 class="vl-section-heading p-name">M-sets and Yoneda for monoids</h1><p class=vl-section-meta><time class=dt-published datetime=2022-07-15>15 Jul 2022</time></p></header><div class="vl-section-body vl-single e-content"><p>The Yoneda lemma says that for a category <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math>, an object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math>, and a functor <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>:</mo><mi mathvariant="double-struck">C</mi><mo>→</mo><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">S:\mathbb{C}\to\textbf{Sets}</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><mo>−</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{Nat}(\operatorname{hom}(C,-),S)</annotation></semantics></math> is in bijection with <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(C)</annotation></semantics></math>. These bijections are given by <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>:</mo><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><mo>−</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>→</mo><mi>S</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha: \operatorname{Nat}(\operatorname{hom}(C,-),S)\to S(C)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>:</mo><mi>S</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mo>→</mo><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><mo>−</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\beta: S(C) \to \operatorname{Nat}(\operatorname{hom}(C,-),S)</annotation></semantics></math> defined as <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>σ</mi><mi>C</mi></msub><mo stretchy="false">(</mo><msub><mn>1</mn><mi>C</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha(\sigma)=\sigma_ {C}(1_ {C})</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo stretchy="false">(</mo><mi>c</mi><msub><mo stretchy="false">)</mo><mi>A</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mi>S</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\beta(c)_ {A}(f)=S(f)(c)</annotation></semantics></math><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. This is the covariant form of the Yoneda lemma. There is also a contravariant form that specifies the bijective correspondence <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>≈</mo><mi>S</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{Nat}(\operatorname{hom}(-,C),S)\approx S(C)</annotation></semantics></math>. Setting <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S=\operatorname{hom}(-,C&#x27;)</annotation></semantics></math>, the Yoneda lemma tells us that natural transformations between the functors <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(-,C)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(-,C&#x27;)</annotation></semantics></math> are in bijection with elements of the set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(C,C&#x27;)</annotation></semantics></math>.</p><hr><p>Let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> be a monoid, then a left <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi></mrow><annotation encoding="application/x-tex">\mathcal{X}</annotation></semantics></math> is an object in the functor category <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant="bold">Sets</mtext><mi>M</mi></msup></mrow><annotation encoding="application/x-tex">\textbf{Sets}^M</annotation></semantics></math><sup id=fnref1:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. Let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi><mo>:</mo><mi>M</mi><mo>→</mo><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\mathcal{X}:M\to\textbf{Sets}</annotation></semantics></math> be a covariant functor then <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi></mrow><annotation encoding="application/x-tex">\mathcal{X}</annotation></semantics></math> specifies an object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\textbf{Sets}</annotation></semantics></math>, the image of the unique object of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> under <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi></mrow><annotation encoding="application/x-tex">\mathcal{X}</annotation></semantics></math>, together with an endomorphism <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo>:</mo><mi>X</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\mathcal{X}(u):X\to X</annotation></semantics></math> for each morphism <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> (i.e. an element of the monoid <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>) that maps <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>↦</mo><mi>u</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">x\mapsto ux</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mi mathvariant="script">X</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="script">X</mi><mo stretchy="false">(</mo><mi>u</mi><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{X}(u)\mathcal{X}(v)=\mathcal{X}(uv)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mn>1</mn><mi>X</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{X}(e)=1_ {X}</annotation></semantics></math>. Similarly, a contravariant functor <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi><mo>:</mo><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>→</mo><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\mathcal{X}:M^{op}\to\textbf{Sets}</annotation></semantics></math> is a right <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set (or equivalently, an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">M^{op}</annotation></semantics></math>-set), but must instead satisfy <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi><mo stretchy="false">(</mo><mi>v</mi><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="script">X</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mi mathvariant="script">X</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{X}(vu) = \mathcal{X}(u)\mathcal{X}(v)</annotation></semantics></math>. When we refer to &ldquo;<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-sets&rdquo; we mean left <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-sets.</p><p>The monoid <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> itself is an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set. Since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>, viewed as a category, has only a single object, the set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}_  {M}(\{M\},\{M\})</annotation></semantics></math> is the set of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set endomorphisms of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{M\}</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> and so <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>=</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {M}(\{M\},\{M\})=M</annotation></semantics></math>. Note that the set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {M}(\{M\},\{M\})</annotation></semantics></math> inherits the monoid structure from the properties of composition of morphisms in a category. The covariant functor <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo>−</mo><mo stretchy="false">)</mo><mo>:</mo><mi>M</mi><mo>→</mo><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {M}(\{M\},-):M\to \textbf{Sets}</annotation></semantics></math> is a <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U(M)</annotation></semantics></math> (where <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>:</mo><mtext mathvariant="bold">Mon</mtext><mo>→</mo><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">U:\textbf{Mon}\to\textbf{Sets}</annotation></semantics></math> is the forgetful functor) with <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> acting on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U(M)</annotation></semantics></math> by left multiplication since for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">u\in M</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>:</mo><mi>M</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {M}(\{M\},u):M\to M</annotation></semantics></math> is defined by <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>u</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {M}(\{M\},u)(x)=ux</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">x\in M</annotation></semantics></math>. Similarly, the contravariant functor <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>:</mo><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>→</mo><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {M}(-,\{M\}):M^{op}\to \textbf{Sets}</annotation></semantics></math> is a <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U(M)</annotation></semantics></math> with <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> acting on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U(M)</annotation></semantics></math> by right multiplication. As a result, we denote the <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U(M)</annotation></semantics></math> as <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>.</p><hr><p>Consider an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>:</mo><mi>M</mi><mo>→</mo><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">S:M\to \textbf{Sets}</annotation></semantics></math>, then a natural transformation <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo>:</mo><mi>M</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">\tau : M \to S</annotation></semantics></math> is an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set homomorphism from <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math><sup id=fnref2:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. The map <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo>:</mo><mi>M</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">\tau : M\to S</annotation></semantics></math> is the unique component of the natural transformation. The naturality condition is satisfied since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math> is a <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set homomorphism, that is, for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math> a morphism in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>,</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>τ</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>τ</mi><mo stretchy="false">(</mo><mi>u</mi><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>u</mi><mi>τ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>S</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>τ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\tau (M(u)(x))=\tau (ux)=u\tau (x)=S(u)(\tau (x))</annotation></semantics></math><p>for all <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">x\in M</annotation></semantics></math>.</p><p>Now, we can form the set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><mi>M</mi></msup></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {\textbf{Sets}^M}(M,S)</annotation></semantics></math> which consists of morphisms <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">M\to S</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-sets (i.e. <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set homomorphisms). These morphisms are natural transformations of the functors <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math>, so</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><mi>M</mi></msup></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo>−</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {\textbf{Sets}^M}(M,S)=\operatorname{Nat}(M,S)=\operatorname{Nat}(\operatorname{hom}_ {M}(\{M\},-),S)</annotation></semantics></math><p>since we can represent <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> with the functor <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo>−</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {M}(\{M\},-)</annotation></semantics></math> as every monoid acts on itself by left or right multiplication. Hence by the Yoneda lemma,</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><mi>M</mi></msup></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo>−</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>≈</mo><mi>S</mi><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>=</mo><mi>S</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {\textbf{Sets}^M}(M,S) = \operatorname{Nat}(\operatorname{hom}_ {M}(\{M\},-),S)\approx S(\{M\})=S.</annotation></semantics></math><p>We have proved the following result,</p><blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set homomorphisms <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">M\to S</annotation></semantics></math> correspond bijectively to elements of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math>.</p></blockquote><p>This bijection is given by the maps <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>:</mo><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><mi>M</mi></msup></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">\alpha:\operatorname{hom}_ {\textbf{Sets}^M}(M,S)\to S</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>:</mo><mi>S</mi><mo>→</mo><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><mi>M</mi></msup></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\beta:S\to\operatorname{hom}_ {\textbf{Sets}^M}(M,S)</annotation></semantics></math> defined by</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">)</mo><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mtext> and,</mtext></mrow><annotation encoding="application/x-tex">\alpha(\sigma)=\sigma(e)\text{ and,}</annotation></semantics></math><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>β</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>S</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\beta(s)(x)=S(x)(s)=xs.</annotation></semantics></math><p>They are inverse to each other since</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mi>β</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>β</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><mi>e</mi><mi>s</mi><mo>=</mo><mi>s</mi><mtext> and,</mtext></mrow><annotation encoding="application/x-tex">\alpha(\beta(s)(x))=\beta(s)(e)=es=s\text{ and,}</annotation></semantics></math><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>β</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>S</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mi>α</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mi>σ</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>x</mi><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\beta(\alpha(\sigma))(x)=S(x)(\alpha(\sigma))=x\alpha(\sigma)=x\sigma(e)=\sigma(xe)=\sigma(x).</annotation></semantics></math><p>We can interpret this bijection as follows, the choice of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma(e)</annotation></semantics></math> determines every other value <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma(x)</annotation></semantics></math> for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">x\in M</annotation></semantics></math> since</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>x</mi><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mi>σ</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma(x)=\sigma(xe)=x\sigma(e)</annotation></semantics></math><p>as <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math> is an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set homomorphism<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</p><p><em>Cayley&rsquo;s Theorem</em> arises as a special case of the above result. For a group <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math>, set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mi>S</mi><mo>=</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">M=S=G</annotation></semantics></math> then we have that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mi>G</mi><mo stretchy="false">)</mo><mo>≈</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}(G,G)\approx G</annotation></semantics></math><p>and since the set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(G,G)</annotation></semantics></math> contains automorphisms of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math>, it is a subgroup of the group of all permutations on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math>.</p><hr><p>There is a counterpart to the bijection <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>≈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}(M,S)\approx S</annotation></semantics></math> in linear algebra. Consider a field <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">K</mi></mrow><annotation encoding="application/x-tex">\mathbb{K}</annotation></semantics></math> and a <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">K</mi></mrow><annotation encoding="application/x-tex">\mathbb{K}</annotation></semantics></math>-vector space <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>, then <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="double-struck">K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo>≈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}(\mathbb{K},V)\approx V</annotation></semantics></math>. This bijection is given by <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>:</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="double-struck">K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\alpha:\operatorname{hom}(\mathbb{K},V)\to V</annotation></semantics></math> defined as <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">)</mo><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha(\sigma)=\sigma(1)</annotation></semantics></math>. The map <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math> is clearly linear and injective. To see that it is surjective, notice that for any <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v\in V</annotation></semantics></math>, there is a map <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>∈</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="double-struck">K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma\in\operatorname{hom}(\mathbb{K},V)</annotation></semantics></math> that maps the multiplicative identity <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math> onto <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math>, namely, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">\sigma(k)=kv</annotation></semantics></math>. The inverse map <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>:</mo><mi>V</mi><mo>→</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="double-struck">K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\beta:V\to\operatorname{hom}(\mathbb{K},V)</annotation></semantics></math> is given by <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">\beta(v)(k)=kv</annotation></semantics></math>, and we have that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mi>β</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>β</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mi>v</mi><mo>=</mo><mi>v</mi><mtext> and,</mtext></mrow><annotation encoding="application/x-tex">\alpha(\beta(v)(k))=\beta(v)(1)=1v=v\text{ and,}</annotation></semantics></math><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>β</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mi>β</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mi>σ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\beta(\alpha(\sigma))(k)=\beta(\sigma(1))(k)=k\sigma(1)=\sigma(k).</annotation></semantics></math><p>However, we are not able to obtain this result from the Yoneda lemma as it has been formulated here. A stronger result, the <em>enriched Yoneda lemma</em>, is required<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><hr><p>Let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> be a category, then the Yoneda embedding is the functor <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>:</mo><mi mathvariant="double-struck">C</mi><mo>→</mo><msup><mtext mathvariant="bold">Sets</mtext><msup><mi mathvariant="double-struck">C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></mrow><annotation encoding="application/x-tex">Y:\mathbb{C}\to\textbf{Sets}^{\mathbb{C}^{op}}</annotation></semantics></math> that maps every object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> to the functor <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mo>:</mo><msup><mi mathvariant="double-struck">C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>→</mo><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\operatorname{hom}(-,C):\mathbb{C}^{op}\to\textbf{Sets}</annotation></semantics></math> and every morphism <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>:</mo><mi>C</mi><mo>→</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">c:C\to C&#x27;</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> to the natural transformation <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mo>:</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mo>→</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(-,c):\operatorname{hom}(-,C)\to\operatorname{hom}(-,C&#x27;)</annotation></semantics></math>, where each component of the natural transformation is defined by <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>c</mi><msub><mo stretchy="false">)</mo><mi>A</mi></msub><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(-,c)_ {A}=\operatorname{hom}(A,c)</annotation></semantics></math> for each object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> (i.e. postcomposition with <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math>). The Yoneda embedding is fully faithful which follows from the Yoneda lemma<sup id=fnref3:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. This means that the functor <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> preserves the relationships that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> shares with every other object in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> and so <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> fully faithfully embeds <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> into <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi mathvariant="double-struck">C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></mrow><annotation encoding="application/x-tex">\textbf{Sets}^{\mathbb{C}^{op}}</annotation></semantics></math>. That is, for every natural transformation <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo>:</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mo>→</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\tau:\operatorname{hom}(-,C)\to\operatorname{hom}(-,C&#x27;)</annotation></semantics></math> there is exactly one morphism <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>:</mo><mi>C</mi><mo>→</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">c:C\to C&#x27;</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mo>=</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}(-,c)=\tau</annotation></semantics></math>. Using this embedding, we are able to work with any category <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> by embedding it in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi mathvariant="double-struck">C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></mrow><annotation encoding="application/x-tex">\textbf{Sets}^{\mathbb{C}^{op}}</annotation></semantics></math> which, in general, has `nicer&rsquo; properties and is easier to work with<sup id=fnref1:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><p>We are able to obtain the Yoneda embedding by using the Yoneda lemma in the case where <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S=\operatorname{hom}(-,C&#x27;)</annotation></semantics></math> for some object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">C&#x27;</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> since the Yoneda lemma says that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{Nat}(\operatorname{hom}(-,C),\operatorname{hom}(-,C&#x27;))</annotation></semantics></math> is in bijection with <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(C,C&#x27;)</annotation></semantics></math>, which is exactly the Yoneda embedding which assigns to each morphism <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>:</mo><mi>C</mi><mo>→</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">c:C\to C&#x27;</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> the natural transformation <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(-,c)</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi mathvariant="double-struck">C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></mrow><annotation encoding="application/x-tex">\textbf{Sets}^{\mathbb{C}^{op}}</annotation></semantics></math>.</p><p>Since the Yoneda embedding <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> fully faithfully embeds <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> into <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi mathvariant="double-struck">C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></mrow><annotation encoding="application/x-tex">\textbf{Sets}^{\mathbb{C}^{op}}</annotation></semantics></math>, we have that, for any two objects <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">C&#x27;</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math>,</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">(</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≈</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{Nat}(Y(C),Y(C&#x27;))=\operatorname{Nat}(\operatorname{hom}(-,C),\operatorname{hom}(-,C&#x27;))\approx \operatorname{hom}(C,C&#x27;)</annotation></semantics></math><p>and hence, there is a relationship <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi><mo>⟷</mo><msup><mtext mathvariant="bold">Sets</mtext><msup><mi mathvariant="double-struck">C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup><mo>⟷</mo><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\mathbb{C}\longleftrightarrow\textbf{Sets}^{\mathbb{C}^{op}}\longleftrightarrow\textbf{Sets}</annotation></semantics></math> that allows us to characterise an object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> by its relationships to all other objects <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">C&#x27;</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math>. That is, the properties of any object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> are encoded in the sets <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(C,C&#x27;)</annotation></semantics></math> for each <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">C&#x27;</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math>.</p><hr><p>Let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>M</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{M}</annotation></semantics></math> be the monoid of all maps <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">M\to M</annotation></semantics></math> (not just monoid homomorphisms) and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>M</mi><mo>→</mo><mover accent="true"><mi>M</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">f:M\to\hat{M}</annotation></semantics></math> map each <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">x\in M</annotation></semantics></math> to the map <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>:</mo><mi>M</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">f(x):M\to M</annotation></semantics></math> defined by <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">f(x)(y)=xy</annotation></semantics></math>. Let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>:</mo><mi>M</mi><mo>→</mo><msup><mtext mathvariant="bold">Sets</mtext><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></mrow><annotation encoding="application/x-tex">Y: M\to\textbf{Sets}^{M^{op}}</annotation></semantics></math> be the Yoneda embedding of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> into <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></mrow><annotation encoding="application/x-tex">\textbf{Sets}^{M^{op}}</annotation></semantics></math>. Then <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x) = \operatorname{hom}(\{M\},x) = \operatorname{hom}(-,x)=Y(x)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>=</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">Y(\{M\})=\operatorname{hom}(-,\{M\})=\operatorname{hom}(\{M\},\{M\})=M</annotation></semantics></math> since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> is a single object category. Now, since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> is fully faithful, the induced functor,</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>Y</mi><mrow><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo></mrow></msub><mo>:</mo><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>→</mo><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y_ {\{M\},\{M\}}:\operatorname{hom}_ {M}(\{M\},\{M\})\to\operatorname{hom}_ {\textbf{Sets}^{M^{op}}}(Y(\{M\}),Y(\{M\}))</annotation></semantics></math><p>is bijective. But, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>=</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {M}(\{M\},\{M\})=M</annotation></semantics></math> and</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">)</mo><mo>⊂</mo><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mtext mathvariant="bold">Sets</mtext></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">)</mo><mo>=</mo><mover accent="true"><mi>M</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {\textbf{Sets}^{M^{op}}}(Y(\{M\}),Y(\{M\}))=\operatorname{hom}_ {\textbf{Sets}^{M^{op}}}(M,M)\subset\operatorname{hom}_ {\textbf{Sets}}(M,M) = \hat{M}</annotation></semantics></math><p>since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y(\{M\})</annotation></semantics></math> is the <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">M^{op}</annotation></semantics></math>-set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U(M)</annotation></semantics></math> which is <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> viewed as a right <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set. So we have that the induced functor</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>Y</mi><mrow><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo></mrow></msub><mo>:</mo><mi>M</mi><mo>→</mo><mover accent="true"><mi>M</mi><mo>^</mo></mover><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">Y_ {\{M\},\{M\}}:M\to\hat{M},</annotation></semantics></math><p>defined by <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mrow><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y_ {\{M\},\{M\}}(x) =Y(x)= f(x)</annotation></semantics></math>, is bijective onto <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {\textbf{Sets}^{M^{op}}}(M,M)</annotation></semantics></math>. However, it is only injective into <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>M</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{M}</annotation></semantics></math>. Now, since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>u</mi><mi>v</mi><mo stretchy="false">)</mo><mi>y</mi><mo>=</mo><mi>u</mi><mo stretchy="false">(</mo><mi>v</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>v</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(uv)(y)=(uv)y=u(vy)=f(u)(vy)=f(u)f(v)(y)</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>M</mi><mo>→</mo><mover accent="true"><mi>M</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">f:M\to\hat{M}</annotation></semantics></math> is an injective homomorphism of monoids. The image of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> is the image of the induced functor which is just the set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {\textbf{Sets}^{M^{op}}}(M,M)</annotation></semantics></math> of all <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">M^{op}</annotation></semantics></math>-set homomorphisms from <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> (or equivalently, right <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set homomorphisms from <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>).</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>George Janelidze. Category theory: A first course. Lecture Notes, 2020.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref2:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref3:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Emily Riehl. <em>Category theory in context</em>. Dover Publications, 2017.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>George Janelidze. Conversation on yoneda lemma. Personal communication 07/06/22, 2022.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></article></div></main><div class=vl-footer-note>© 2024 by Elias Judin</div></div></div></body></html>