<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>M-sets and Yoneda for monoids — Elias Judin</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Exercises in category theory: M-sets and the Yoneda lemma for monoids"><meta name=theme-color content="#ffffff"><meta name=author content="Elias Judin"><link rel=canonical href=https://eliasjudin.github.io/blog/yoneda/><meta property="og:url" content="https://eliasjudin.github.io/blog/yoneda/"><meta property="og:title" content="M-sets and Yoneda for monoids — Elias Judin"><meta property="og:description" content="Exercises in category theory: M-sets and the Yoneda lemma for monoids"><meta property="og:type" content="article"><meta property="og:site_name" content="Elias Judin"><meta property="og:image" content="https://eliasjudin.github.io/assets/images/banner-social.png"><meta property="og:image:alt" content="M-sets and Yoneda for monoids — Elias Judin"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="M-sets and Yoneda for monoids — Elias Judin"><meta name=twitter:description content="Exercises in category theory: M-sets and the Yoneda lemma for monoids"><meta name=twitter:image content="https://eliasjudin.github.io/assets/images/banner-social.png"><meta name=twitter:image:alt content="M-sets and Yoneda for monoids — Elias Judin"><link rel=alternate type=application/rss+xml title="Elias Judin" href=https://eliasjudin.github.io/index.xml><meta property="article:published_time" content="2022-07-15T10:51:26+04:00"><meta property="article:modified_time" content="2022-07-15T10:51:26+04:00"><link rel=icon type=image/svg+xml href=/favicon.svg><link rel=stylesheet href=/css/style.min.fd8480d5a404069ac39ef4109f2bc7205f211bcf01336ea27c20ef365b0929b3.css integrity="sha256-/YSA1aQEBprDnvQQnyvHIF8hG88BM26ifCDvNlsJKbM="><script type=application/ld+json>[{"@context":"https://schema.org","@type":"WebSite","description":"Exercises in category theory: M-sets and the Yoneda lemma for monoids","inLanguage":"en","name":"Elias Judin","publisher":{"@type":"Person","name":"Elias Judin"},"url":"https://eliasjudin.github.io/"},{"@context":"https://schema.org","@type":"Article","author":{"@type":"Person","name":"Elias Judin"},"dateModified":"2022-07-15T10:51:26+04:00","datePublished":"2022-07-15T10:51:26+04:00","description":"Exercises in category theory: M-sets and the Yoneda lemma for monoids","headline":"M-sets and Yoneda for monoids","image":"https://eliasjudin.github.io/assets/images/banner-social.png","url":"https://eliasjudin.github.io/blog/yoneda/"}]</script><meta name=generator content="Hugo 0.150.0"></head><body><a class=vl-skip-link href=#main>Skip to main content</a><div class=vl-page><div class=vl-frame><header class=vl-header role=banner><div class=vl-top><div><form class=vl-top-form aria-label="Navigate site"><label class=vl-sr-only for=vl-top-select>Navigate to page</label>
<select id=vl-top-select class=vl-top-select onchange="this.value&&(window.location.href=this.value)"><option value disabled>Navigate...</option><option value=/>home</option><option value=/blog selected>mathematics blog</option><option value=/log>latest notes</option><option value=/cv>curriculum vitae</option><option value disabled>..................................................</option><option value=/contact>contact</option><option value=https://github.com/eliasjudin>github</option><option value=https://za.linkedin.com/in/elias-judin-a6988325a>linkedin</option></select></form><nav class=vl-sr-only aria-label="Primary site navigation"><ul><li><a href=/>home</a></li><li><a href=/blog aria-current=page>mathematics blog</a></li><li><a href=/log>latest notes</a></li><li><a href=/cv>curriculum vitae</a></li><li><a href=/contact>contact</a></li><li><a href=https://github.com/eliasjudin>github</a></li><li><a href=https://za.linkedin.com/in/elias-judin-a6988325a>linkedin</a></li></ul></nav></div><div class=vl-top-title><a href=/ class=vl-top-title-link>Elias Judin</a></div></div><div class=vl-tickers role=presentation><div class=vl-ticker data-speed=medium><span class=vl-sr-only>Elias Judin, Category theory, Universal algebra</span><div class=vl-ticker-track aria-hidden=true>&nbsp;: Elias Judin : Category theory : Universal algebra :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: Elias Judin : Category theory : Universal algebra :&nbsp;&nbsp;&nbsp;&nbsp;</div></div><div class=vl-ticker data-speed=fast><span class=vl-sr-only>Lean4 @ Harmonic, Project Numina labeling, UCT category seminars, UCT grant 2024</span><div class=vl-ticker-track aria-hidden=true>&nbsp;:: Lean4 @ Harmonic :: Project Numina labeling :: UCT category seminars :: UCT grant 2024 ::&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: Lean4 @ Harmonic :: Project Numina labeling :: UCT category seminars :: UCT grant 2024 ::&nbsp;&nbsp;&nbsp;&nbsp;</div></div><div class=vl-ticker data-speed=slow><span class=vl-sr-only>University of Cape Town, Harmonic, Project Numina, Category Theory Group</span><div class=vl-ticker-track aria-hidden=true>&nbsp;::: University of Cape Town ::: Harmonic ::: Project Numina ::: Category Theory Group :::&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::: University of Cape Town ::: Harmonic ::: Project Numina ::: Category Theory Group :::&nbsp;&nbsp;&nbsp;&nbsp;</div></div></div></header><main id=main class=vl-main><div class="vl-section vl-section--post"><article class=vl-section-inner><header class=vl-section-header><h1 class=vl-section-heading><strong>M-sets and Yoneda for monoids</strong></h1><p class=vl-section-meta><time datetime=2022-07-15>15 Jul 2022</time></p></header><div class="vl-section-body vl-single"><p>The Yoneda lemma says that for a category <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math>, an object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math>, and a functor <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>:</mo><mi mathvariant="double-struck">C</mi><mo>→</mo><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">S:\mathbb{C}\to\textbf{Sets}</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><mo>−</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{Nat}(\operatorname{hom}(C,-),S)</annotation></semantics></math> is in bijection with <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(C)</annotation></semantics></math>. These bijections are given by <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>:</mo><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><mo>−</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>→</mo><mi>S</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha: \operatorname{Nat}(\operatorname{hom}(C,-),S)\to S(C)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>:</mo><mi>S</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mo>→</mo><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><mo>−</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\beta: S(C) \to \operatorname{Nat}(\operatorname{hom}(C,-),S)</annotation></semantics></math> defined as <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>σ</mi><mi>C</mi></msub><mo stretchy="false">(</mo><msub><mn>1</mn><mi>C</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha(\sigma)=\sigma_ {C}(1_ {C})</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo stretchy="false">(</mo><mi>c</mi><msub><mo stretchy="false">)</mo><mi>A</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mi>S</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\beta(c)_ {A}(f)=S(f)(c)</annotation></semantics></math><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. This is the covariant form of the Yoneda lemma. There is also a contravariant form that specifies the bijective correspondence <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>≈</mo><mi>S</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{Nat}(\operatorname{hom}(-,C),S)\approx S(C)</annotation></semantics></math>. Setting <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S=\operatorname{hom}(-,C&#x27;)</annotation></semantics></math>, the Yoneda lemma tells us that natural transformations between the functors <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(-,C)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(-,C&#x27;)</annotation></semantics></math> are in bijection with elements of the set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(C,C&#x27;)</annotation></semantics></math>.</p><hr><p>Let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> be a monoid, then a left <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi></mrow><annotation encoding="application/x-tex">\mathcal{X}</annotation></semantics></math> is an object in the functor category <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant="bold">Sets</mtext><mi>M</mi></msup></mrow><annotation encoding="application/x-tex">\textbf{Sets}^M</annotation></semantics></math><sup id=fnref1:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. Let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi><mo>:</mo><mi>M</mi><mo>→</mo><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\mathcal{X}:M\to\textbf{Sets}</annotation></semantics></math> be a covariant functor then <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi></mrow><annotation encoding="application/x-tex">\mathcal{X}</annotation></semantics></math> specifies an object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\textbf{Sets}</annotation></semantics></math>, the image of the unique object of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> under <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi></mrow><annotation encoding="application/x-tex">\mathcal{X}</annotation></semantics></math>, together with an endomorphism <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo>:</mo><mi>X</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\mathcal{X}(u):X\to X</annotation></semantics></math> for each morphism <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> (i.e. an element of the monoid <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>) that maps <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>↦</mo><mi>u</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">x\mapsto ux</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mi mathvariant="script">X</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="script">X</mi><mo stretchy="false">(</mo><mi>u</mi><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{X}(u)\mathcal{X}(v)=\mathcal{X}(uv)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mn>1</mn><mi>X</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{X}(e)=1_ {X}</annotation></semantics></math>. Similarly, a contravariant functor <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi><mo>:</mo><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>→</mo><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\mathcal{X}:M^{op}\to\textbf{Sets}</annotation></semantics></math> is a right <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set (or equivalently, an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">M^{op}</annotation></semantics></math>-set), but must instead satisfy <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi><mo stretchy="false">(</mo><mi>v</mi><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="script">X</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mi mathvariant="script">X</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{X}(vu) = \mathcal{X}(u)\mathcal{X}(v)</annotation></semantics></math>. When we refer to &ldquo;<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-sets&rdquo; we mean left <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-sets.</p><p>The monoid <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> itself is an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set. Since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>, viewed as a category, has only a single object, the set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}_  {M}(\{M\},\{M\})</annotation></semantics></math> is the set of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set endomorphisms of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{M\}</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> and so <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>=</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {M}(\{M\},\{M\})=M</annotation></semantics></math>. Note that the set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {M}(\{M\},\{M\})</annotation></semantics></math> inherits the monoid structure from the properties of composition of morphisms in a category. The covariant functor <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo>−</mo><mo stretchy="false">)</mo><mo>:</mo><mi>M</mi><mo>→</mo><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {M}(\{M\},-):M\to \textbf{Sets}</annotation></semantics></math> is a <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U(M)</annotation></semantics></math> (where <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>:</mo><mtext mathvariant="bold">Mon</mtext><mo>→</mo><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">U:\textbf{Mon}\to\textbf{Sets}</annotation></semantics></math> is the forgetful functor) with <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> acting on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U(M)</annotation></semantics></math> by left multiplication since for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">u\in M</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>:</mo><mi>M</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {M}(\{M\},u):M\to M</annotation></semantics></math> is defined by <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>u</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {M}(\{M\},u)(x)=ux</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">x\in M</annotation></semantics></math>. Similarly, the contravariant functor <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>:</mo><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>→</mo><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {M}(-,\{M\}):M^{op}\to \textbf{Sets}</annotation></semantics></math> is a <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U(M)</annotation></semantics></math> with <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> acting on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U(M)</annotation></semantics></math> by right multiplication. As a result, we denote the <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U(M)</annotation></semantics></math> as <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>.</p><hr><p>Consider an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>:</mo><mi>M</mi><mo>→</mo><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">S:M\to \textbf{Sets}</annotation></semantics></math>, then a natural transformation <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo>:</mo><mi>M</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">\tau : M \to S</annotation></semantics></math> is an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set homomorphism from <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math><sup id=fnref2:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. The map <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo>:</mo><mi>M</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">\tau : M\to S</annotation></semantics></math> is the unique component of the natural transformation. The naturality condition is satisfied since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math> is a <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set homomorphism, that is, for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math> a morphism in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>,</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>τ</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>τ</mi><mo stretchy="false">(</mo><mi>u</mi><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>u</mi><mi>τ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>S</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>τ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\tau (M(u)(x))=\tau (ux)=u\tau (x)=S(u)(\tau (x))</annotation></semantics></math><p>for all <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">x\in M</annotation></semantics></math>.</p><p>Now, we can form the set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><mi>M</mi></msup></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {\textbf{Sets}^M}(M,S)</annotation></semantics></math> which consists of morphisms <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">M\to S</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-sets (i.e. <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set homomorphisms). These morphisms are natural transformations of the functors <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math>, so</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><mi>M</mi></msup></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo>−</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {\textbf{Sets}^M}(M,S)=\operatorname{Nat}(M,S)=\operatorname{Nat}(\operatorname{hom}_ {M}(\{M\},-),S)</annotation></semantics></math><p>since we can represent <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> with the functor <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo>−</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {M}(\{M\},-)</annotation></semantics></math> as every monoid acts on itself by left or right multiplication. Hence by the Yoneda lemma,</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><mi>M</mi></msup></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo>−</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>≈</mo><mi>S</mi><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>=</mo><mi>S</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {\textbf{Sets}^M}(M,S) = \operatorname{Nat}(\operatorname{hom}_ {M}(\{M\},-),S)\approx S(\{M\})=S.</annotation></semantics></math><p>We have proved the following result,</p><blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set homomorphisms <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">M\to S</annotation></semantics></math> correspond bijectively to elements of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math>.</p></blockquote><p>This bijection is given by the maps <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>:</mo><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><mi>M</mi></msup></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">\alpha:\operatorname{hom}_ {\textbf{Sets}^M}(M,S)\to S</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>:</mo><mi>S</mi><mo>→</mo><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><mi>M</mi></msup></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\beta:S\to\operatorname{hom}_ {\textbf{Sets}^M}(M,S)</annotation></semantics></math> defined by</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">)</mo><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mtext> and,</mtext></mrow><annotation encoding="application/x-tex">\alpha(\sigma)=\sigma(e)\text{ and,}</annotation></semantics></math><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>β</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>S</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\beta(s)(x)=S(x)(s)=xs.</annotation></semantics></math><p>They are inverse to each other since</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mi>β</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>β</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><mi>e</mi><mi>s</mi><mo>=</mo><mi>s</mi><mtext> and,</mtext></mrow><annotation encoding="application/x-tex">\alpha(\beta(s)(x))=\beta(s)(e)=es=s\text{ and,}</annotation></semantics></math><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>β</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>S</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mi>α</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mi>σ</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>x</mi><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\beta(\alpha(\sigma))(x)=S(x)(\alpha(\sigma))=x\alpha(\sigma)=x\sigma(e)=\sigma(xe)=\sigma(x).</annotation></semantics></math><p>We can interpret this bijection as follows, the choice of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma(e)</annotation></semantics></math> determines every other value <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma(x)</annotation></semantics></math> for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">x\in M</annotation></semantics></math> since</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>x</mi><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mi>σ</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma(x)=\sigma(xe)=x\sigma(e)</annotation></semantics></math><p>as <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math> is an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set homomorphism<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</p><p><em>Cayley&rsquo;s Theorem</em> arises as a special case of the above result. For a group <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math>, set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mi>S</mi><mo>=</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">M=S=G</annotation></semantics></math> then we have that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mi>G</mi><mo stretchy="false">)</mo><mo>≈</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}(G,G)\approx G</annotation></semantics></math><p>and since the set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(G,G)</annotation></semantics></math> contains automorphisms of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math>, it is a subgroup of the group of all permutations on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math>.</p><hr><p>There is a counterpart to the bijection <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>≈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}(M,S)\approx S</annotation></semantics></math> in linear algebra. Consider a field <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">K</mi></mrow><annotation encoding="application/x-tex">\mathbb{K}</annotation></semantics></math> and a <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">K</mi></mrow><annotation encoding="application/x-tex">\mathbb{K}</annotation></semantics></math>-vector space <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>, then <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="double-struck">K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo>≈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}(\mathbb{K},V)\approx V</annotation></semantics></math>. This bijection is given by <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>:</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="double-struck">K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\alpha:\operatorname{hom}(\mathbb{K},V)\to V</annotation></semantics></math> defined as <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">)</mo><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha(\sigma)=\sigma(1)</annotation></semantics></math>. The map <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math> is clearly linear and injective. To see that it is surjective, notice that for any <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v\in V</annotation></semantics></math>, there is a map <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>∈</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="double-struck">K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma\in\operatorname{hom}(\mathbb{K},V)</annotation></semantics></math> that maps the multiplicative identity <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math> onto <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math>, namely, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">\sigma(k)=kv</annotation></semantics></math>. The inverse map <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>:</mo><mi>V</mi><mo>→</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="double-struck">K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\beta:V\to\operatorname{hom}(\mathbb{K},V)</annotation></semantics></math> is given by <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">\beta(v)(k)=kv</annotation></semantics></math>, and we have that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mi>β</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>β</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mi>v</mi><mo>=</mo><mi>v</mi><mtext> and,</mtext></mrow><annotation encoding="application/x-tex">\alpha(\beta(v)(k))=\beta(v)(1)=1v=v\text{ and,}</annotation></semantics></math><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>β</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mi>β</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mi>σ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\beta(\alpha(\sigma))(k)=\beta(\sigma(1))(k)=k\sigma(1)=\sigma(k).</annotation></semantics></math><p>However, we are not able to obtain this result from the Yoneda lemma as it has been formulated here. A stronger result, the <em>enriched Yoneda lemma</em>, is required<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><hr><p>Let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> be a category, then the Yoneda embedding is the functor <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>:</mo><mi mathvariant="double-struck">C</mi><mo>→</mo><msup><mtext mathvariant="bold">Sets</mtext><msup><mi mathvariant="double-struck">C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></mrow><annotation encoding="application/x-tex">Y:\mathbb{C}\to\textbf{Sets}^{\mathbb{C}^{op}}</annotation></semantics></math> that maps every object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> to the functor <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mo>:</mo><msup><mi mathvariant="double-struck">C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>→</mo><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\operatorname{hom}(-,C):\mathbb{C}^{op}\to\textbf{Sets}</annotation></semantics></math> and every morphism <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>:</mo><mi>C</mi><mo>→</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">c:C\to C&#x27;</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> to the natural transformation <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mo>:</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mo>→</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(-,c):\operatorname{hom}(-,C)\to\operatorname{hom}(-,C&#x27;)</annotation></semantics></math>, where each component of the natural transformation is defined by <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>c</mi><msub><mo stretchy="false">)</mo><mi>A</mi></msub><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(-,c)_ {A}=\operatorname{hom}(A,c)</annotation></semantics></math> for each object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> (i.e. postcomposition with <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math>). The Yoneda embedding is fully faithful which follows from the Yoneda lemma<sup id=fnref3:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. This means that the functor <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> preserves the relationships that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> shares with every other object in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> and so <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> fully faithfully embeds <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> into <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi mathvariant="double-struck">C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></mrow><annotation encoding="application/x-tex">\textbf{Sets}^{\mathbb{C}^{op}}</annotation></semantics></math>. That is, for every natural transformation <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo>:</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mo>→</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\tau:\operatorname{hom}(-,C)\to\operatorname{hom}(-,C&#x27;)</annotation></semantics></math> there is exactly one morphism <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>:</mo><mi>C</mi><mo>→</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">c:C\to C&#x27;</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mo>=</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}(-,c)=\tau</annotation></semantics></math>. Using this embedding, we are able to work with any category <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> by embedding it in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi mathvariant="double-struck">C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></mrow><annotation encoding="application/x-tex">\textbf{Sets}^{\mathbb{C}^{op}}</annotation></semantics></math> which, in general, has `nicer&rsquo; properties and is easier to work with<sup id=fnref1:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><p>We are able to obtain the Yoneda embedding by using the Yoneda lemma in the case where <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S=\operatorname{hom}(-,C&#x27;)</annotation></semantics></math> for some object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">C&#x27;</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> since the Yoneda lemma says that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{Nat}(\operatorname{hom}(-,C),\operatorname{hom}(-,C&#x27;))</annotation></semantics></math> is in bijection with <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(C,C&#x27;)</annotation></semantics></math>, which is exactly the Yoneda embedding which assigns to each morphism <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>:</mo><mi>C</mi><mo>→</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">c:C\to C&#x27;</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> the natural transformation <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(-,c)</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi mathvariant="double-struck">C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></mrow><annotation encoding="application/x-tex">\textbf{Sets}^{\mathbb{C}^{op}}</annotation></semantics></math>.</p><p>Since the Yoneda embedding <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> fully faithfully embeds <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> into <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi mathvariant="double-struck">C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></mrow><annotation encoding="application/x-tex">\textbf{Sets}^{\mathbb{C}^{op}}</annotation></semantics></math>, we have that, for any two objects <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">C&#x27;</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math>,</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">(</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≈</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{Nat}(Y(C),Y(C&#x27;))=\operatorname{Nat}(\operatorname{hom}(-,C),\operatorname{hom}(-,C&#x27;))\approx \operatorname{hom}(C,C&#x27;)</annotation></semantics></math><p>and hence, there is a relationship <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi><mo>⟷</mo><msup><mtext mathvariant="bold">Sets</mtext><msup><mi mathvariant="double-struck">C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup><mo>⟷</mo><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\mathbb{C}\longleftrightarrow\textbf{Sets}^{\mathbb{C}^{op}}\longleftrightarrow\textbf{Sets}</annotation></semantics></math> that allows us to characterise an object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> by its relationships to all other objects <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">C&#x27;</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math>. That is, the properties of any object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> are encoded in the sets <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(C,C&#x27;)</annotation></semantics></math> for each <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">C&#x27;</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math>.</p><hr><p>Let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>M</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{M}</annotation></semantics></math> be the monoid of all maps <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">M\to M</annotation></semantics></math> (not just monoid homomorphisms) and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>M</mi><mo>→</mo><mover accent="true"><mi>M</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">f:M\to\hat{M}</annotation></semantics></math> map each <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">x\in M</annotation></semantics></math> to the map <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>:</mo><mi>M</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">f(x):M\to M</annotation></semantics></math> defined by <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">f(x)(y)=xy</annotation></semantics></math>. Let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>:</mo><mi>M</mi><mo>→</mo><msup><mtext mathvariant="bold">Sets</mtext><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></mrow><annotation encoding="application/x-tex">Y: M\to\textbf{Sets}^{M^{op}}</annotation></semantics></math> be the Yoneda embedding of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> into <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></mrow><annotation encoding="application/x-tex">\textbf{Sets}^{M^{op}}</annotation></semantics></math>. Then <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x) = \operatorname{hom}(\{M\},x) = \operatorname{hom}(-,x)=Y(x)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>=</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">Y(\{M\})=\operatorname{hom}(-,\{M\})=\operatorname{hom}(\{M\},\{M\})=M</annotation></semantics></math> since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> is a single object category. Now, since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> is fully faithful, the induced functor,</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>Y</mi><mrow><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo></mrow></msub><mo>:</mo><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>→</mo><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y_ {\{M\},\{M\}}:\operatorname{hom}_ {M}(\{M\},\{M\})\to\operatorname{hom}_ {\textbf{Sets}^{M^{op}}}(Y(\{M\}),Y(\{M\}))</annotation></semantics></math><p>is bijective. But, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>=</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {M}(\{M\},\{M\})=M</annotation></semantics></math> and</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">)</mo><mo>⊂</mo><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mtext mathvariant="bold">Sets</mtext></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">)</mo><mo>=</mo><mover accent="true"><mi>M</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {\textbf{Sets}^{M^{op}}}(Y(\{M\}),Y(\{M\}))=\operatorname{hom}_ {\textbf{Sets}^{M^{op}}}(M,M)\subset\operatorname{hom}_ {\textbf{Sets}}(M,M) = \hat{M}</annotation></semantics></math><p>since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y(\{M\})</annotation></semantics></math> is the <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">M^{op}</annotation></semantics></math>-set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U(M)</annotation></semantics></math> which is <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> viewed as a right <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set. So we have that the induced functor</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>Y</mi><mrow><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo></mrow></msub><mo>:</mo><mi>M</mi><mo>→</mo><mover accent="true"><mi>M</mi><mo>^</mo></mover><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">Y_ {\{M\},\{M\}}:M\to\hat{M},</annotation></semantics></math><p>defined by <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mrow><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y_ {\{M\},\{M\}}(x) =Y(x)= f(x)</annotation></semantics></math>, is bijective onto <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {\textbf{Sets}^{M^{op}}}(M,M)</annotation></semantics></math>. However, it is only injective into <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>M</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{M}</annotation></semantics></math>. Now, since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>u</mi><mi>v</mi><mo stretchy="false">)</mo><mi>y</mi><mo>=</mo><mi>u</mi><mo stretchy="false">(</mo><mi>v</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>v</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(uv)(y)=(uv)y=u(vy)=f(u)(vy)=f(u)f(v)(y)</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>M</mi><mo>→</mo><mover accent="true"><mi>M</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">f:M\to\hat{M}</annotation></semantics></math> is an injective homomorphism of monoids. The image of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> is the image of the induced functor which is just the set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {\textbf{Sets}^{M^{op}}}(M,M)</annotation></semantics></math> of all <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">M^{op}</annotation></semantics></math>-set homomorphisms from <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> (or equivalently, right <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set homomorphisms from <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>).</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>George Janelidze. Category theory: A first course. Lecture Notes, 2020.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref2:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref3:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Emily Riehl. <em>Category theory in context</em>. Dover Publications, 2017.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>George Janelidze. Conversation on yoneda lemma. Personal communication 07/06/22, 2022.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></article></div></main><div class=vl-footer-note>© 2024 by Elias Judin</div></div></div></body></html>