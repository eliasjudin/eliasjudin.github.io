<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>M-sets and Yoneda for monoids — Elias Judin</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Yoneda lemma for monoids via M-sets: explicit Nat(M(-), X) <-> X bijection, Cayley as a corollary, plus Yoneda embedding and an enriched remark for self-study."><meta name=robots content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=theme-color content="#ffffff"><meta name=author content="Elias Judin"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><link rel=canonical href=https://eliasjudin.github.io/blog/yoneda/><meta property="og:url" content="https://eliasjudin.github.io/blog/yoneda/"><meta property="og:title" content="M-sets and Yoneda for monoids — Elias Judin"><meta property="og:description" content="Yoneda lemma for monoids via M-sets: explicit Nat(M(-), X) <-> X bijection, Cayley as a corollary, plus Yoneda embedding and an enriched remark for self-study."><meta property="og:type" content="article"><meta property="og:site_name" content="Elias Judin"><meta property="og:image" content="https://eliasjudin.github.io/assets/images/banner-social.png"><meta property="og:image:alt" content="M-sets and Yoneda for monoids — Elias Judin"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="M-sets and Yoneda for monoids — Elias Judin"><meta name=twitter:description content="Yoneda lemma for monoids via M-sets: explicit Nat(M(-), X) <-> X bijection, Cayley as a corollary, plus Yoneda embedding and an enriched remark for self-study."><meta name=twitter:image content="https://eliasjudin.github.io/assets/images/banner-social.png"><meta name=twitter:image:alt content="M-sets and Yoneda for monoids — Elias Judin"><link rel=alternate type=application/rss+xml title="Elias Judin" href=https://eliasjudin.github.io/index.xml><meta property="article:published_time" content="2022-07-15T10:51:26+04:00"><meta property="article:modified_time" content="2025-12-25T03:08:08+02:00"><link rel=icon type=image/svg+xml href=/favicon.svg><link rel=preload href=/css/style.min.f1d49839b721c9f35bcda8b272d1ca57dcd26b1c6dfd19cd3d9d6686095413ec.css as=style integrity="sha256-8dSYObchyfNbzaiyctHKV9zSaxxt/RnNPZ1mhglUE+w=" crossorigin=anonymous><link rel=stylesheet href=/css/style.min.f1d49839b721c9f35bcda8b272d1ca57dcd26b1c6dfd19cd3d9d6686095413ec.css integrity="sha256-8dSYObchyfNbzaiyctHKV9zSaxxt/RnNPZ1mhglUE+w=" crossorigin=anonymous media=print onload='this.media="all"'><noscript><link rel=stylesheet href=/css/style.min.f1d49839b721c9f35bcda8b272d1ca57dcd26b1c6dfd19cd3d9d6686095413ec.css integrity="sha256-8dSYObchyfNbzaiyctHKV9zSaxxt/RnNPZ1mhglUE+w=" crossorigin=anonymous></noscript><script defer src=/js/tickers.min.f08a1d80d427b8fb84ae659d7799cba6661e94a2c36e4d9a9e353cce065c6cad.js integrity="sha256-8IodgNQnuPuErmWdd5nLpmYelKLDbk2anjU8zgZcbK0="></script><script type=application/ld+json>[{"@context":"https://schema.org","@id":"https://eliasjudin.github.io/#website","@type":"WebSite","description":"Elias Judin's academic website and mathematics research blog on category theory, universal algebra, topology, and sheaf theory.","inLanguage":"en","name":"Elias Judin","publisher":{"@id":"https://eliasjudin.github.io/#person","@type":"Person","affiliation":[{"@type":"Organization","name":"Harmonic","url":"https://harmonic.fun/"},{"@type":"CollegeOrUniversity","name":"University of Cape Town","url":"https://www.uct.ac.za/"}],"alumniOf":[{"@type":"CollegeOrUniversity","name":"University of Cape Town","url":"https://www.uct.ac.za/"},{"@type":"CollegeOrUniversity","name":"University of the Witwatersrand","url":"https://www.wits.ac.za/"},{"@type":"HighSchool","name":"King David Victory Park High School","url":"https://www.kingdavid.org.za/victory-park-high-school/"}],"award":["Master's Fellowship; UCT Building Research Active Academic Staff Grant (2023, 2024)","Myer Levinson (EMDIN) Scholar (2022, 2023, 2024)","Max Price and Deborah Posel Scholarship nominee (2022)","University Council Merit Scholarship, University of the Witwatersrand (2020, 2021)","Dean's List (University of the Witwatersrand, 2020 Year II, 2021 Year III)"],"jobTitle":"Lean4 mathematician and MSc Mathematics student","knowsAbout":["Category theory","Universal algebra","Topology","Sheaf theory","Lean theorem proving","Quantum computing"],"name":"Elias Judin","sameAs":["https://scholar.google.com/citations?user=fOYPVWwAAAAJ","https://orcid.org/0009-0009-3267-9204","https://www.semanticscholar.org/author/Elias-Judin/2276874240"],"url":"https://eliasjudin.github.io/"},"url":"https://eliasjudin.github.io/"},{"@context":"https://schema.org","@id":"https://eliasjudin.github.io/blog/yoneda/#webpage","@type":"WebPage","description":"Yoneda lemma for monoids via M-sets: explicit Nat(M(-), X) \u003c-\u003e X bijection, Cayley as a corollary, plus Yoneda embedding and an enriched remark for self-study.","inLanguage":"en","isPartOf":{"@id":"https://eliasjudin.github.io/#website"},"name":"M-sets and Yoneda for monoids","primaryImageOfPage":{"@type":"ImageObject","url":"https://eliasjudin.github.io/assets/images/banner-social.png"},"url":"https://eliasjudin.github.io/blog/yoneda/"},{"@context":"https://schema.org","@id":"https://eliasjudin.github.io/blog/yoneda/#article","@type":"ScholarlyArticle","author":[{"@type":"Person","name":"Elias Judin"}],"dateModified":"2025-12-25T03:08:08+02:00","datePublished":"2022-07-15T10:51:26+04:00","description":"Yoneda lemma for monoids via M-sets: explicit Nat(M(-), X) \u003c-\u003e X bijection, Cayley as a corollary, plus Yoneda embedding and an enriched remark for self-study.","headline":"M-sets and Yoneda for monoids","image":["https://eliasjudin.github.io/assets/images/banner-social.png"],"inLanguage":"en","isPartOf":{"@id":"https://eliasjudin.github.io/#website"},"keywords":"category-theory","mainEntityOfPage":{"@id":"https://eliasjudin.github.io/blog/yoneda/#webpage","@type":"WebPage"},"name":"M-sets and Yoneda for monoids","publisher":{"@id":"https://eliasjudin.github.io/#person","@type":"Person","affiliation":[{"@type":"Organization","name":"Harmonic","url":"https://harmonic.fun/"},{"@type":"CollegeOrUniversity","name":"University of Cape Town","url":"https://www.uct.ac.za/"}],"alumniOf":[{"@type":"CollegeOrUniversity","name":"University of Cape Town","url":"https://www.uct.ac.za/"},{"@type":"CollegeOrUniversity","name":"University of the Witwatersrand","url":"https://www.wits.ac.za/"},{"@type":"HighSchool","name":"King David Victory Park High School","url":"https://www.kingdavid.org.za/victory-park-high-school/"}],"award":["Master's Fellowship; UCT Building Research Active Academic Staff Grant (2023, 2024)","Myer Levinson (EMDIN) Scholar (2022, 2023, 2024)","Max Price and Deborah Posel Scholarship nominee (2022)","University Council Merit Scholarship, University of the Witwatersrand (2020, 2021)","Dean's List (University of the Witwatersrand, 2020 Year II, 2021 Year III)"],"jobTitle":"Lean4 mathematician and MSc Mathematics student","knowsAbout":["Category theory","Universal algebra","Topology","Sheaf theory","Lean theorem proving","Quantum computing"],"name":"Elias Judin","sameAs":["https://scholar.google.com/citations?user=fOYPVWwAAAAJ","https://orcid.org/0009-0009-3267-9204","https://www.semanticscholar.org/author/Elias-Judin/2276874240"],"url":"https://eliasjudin.github.io/"},"url":"https://eliasjudin.github.io/blog/yoneda/","wordCount":1141}]</script></head><body><a class=vl-skip-link href=#main>Skip to main content</a><div class=vl-page><div class=vl-frame><header class=vl-header role=banner><div class=vl-top><div><form class=vl-top-form aria-label="navigate site"><label class=vl-sr-only for=vl-top-select>navigate to page</label>
<select id=vl-top-select class=vl-top-select onchange="const option=this.options[this.selectedIndex];if(option&&!option.disabled){const e=option.value;e&&(window.location.href=e)}"><option value=placeholder disabled>navigate...</option><option value=/>home</option><option value=/blog/ selected>mathematics blog</option><option value=/log/>log</option><option value=/cv/>curriculum vitae</option><option value=separator-4 disabled>..................................................</option><option value=/contact/>contact</option><option value=https://github.com/eliasjudin>github</option><option value=https://za.linkedin.com/in/elias-judin-a6988325a>linkedin</option></select></form><nav class=vl-sr-only aria-label="Primary site navigation"><ul><li><a href=/>home</a></li><li><a href=/blog/ aria-current=page>mathematics blog</a></li><li><a href=/log/>log</a></li><li><a href=/cv/>curriculum vitae</a></li><li><a href=/contact/>contact</a></li><li><a href=https://github.com/eliasjudin>github</a></li><li><a href=https://za.linkedin.com/in/elias-judin-a6988325a>linkedin</a></li></ul></nav></div><div class=vl-top-title><a href=/ class=vl-top-title-link>Elias Judin</a></div></div><div id=vl-tickers class=vl-tickers role=presentation><div class=vl-ticker data-speed=medium><div class=vl-ticker-label aria-hidden=true>about</div><div class=vl-ticker-marquee><span class=vl-sr-only>about: Mathematician & AI engineer, category theory, universal algebra, topology & sheaf theory, formal verification, foundation-model infrastructure</span><div class=vl-ticker-track aria-hidden=true>&nbsp;: Mathematician & AI engineer : category theory : universal algebra : topology & sheaf theory : formal verification : foundation-model infrastructure :&nbsp;&nbsp;&nbsp;&nbsp;</div></div></div><div class=vl-ticker data-speed=fast><div class=vl-ticker-label aria-hidden=true>now</div><div class=vl-ticker-marquee><span class=vl-sr-only>now: may 2025 — Lean4 formalization (part-time), march 2025 — AMC/AIME Lean4 labeling, august 2024 — Weekly category seminars, march 2024 — Research grant 2024</span><div class=vl-ticker-track aria-hidden=true>&nbsp;:: may 2025 — Lean4 formalization (part-time) :: march 2025 — AMC/AIME Lean4 labeling :: august 2024 — Weekly category seminars :: march 2024 — Research grant 2024 ::&nbsp;&nbsp;&nbsp;&nbsp;</div></div></div><div class=vl-ticker data-speed=slow><div class=vl-ticker-label aria-hidden=true>affiliations</div><div class=vl-ticker-marquee><span class=vl-sr-only>affiliations: Harmonic, Project Numina, University of Cape Town, University of the Witwatersrand, Kili Technology, Lean Prover community, SAOTA</span><div class=vl-ticker-track aria-hidden=true>&nbsp;::: Harmonic ::: Project Numina ::: University of Cape Town ::: University of the Witwatersrand ::: Kili Technology ::: Lean Prover community ::: SAOTA :::&nbsp;&nbsp;&nbsp;&nbsp;</div></div></div></div></header><main id=main class=vl-main><div class="vl-section vl-section--post"><article class="vl-section-inner h-entry"><nav class=vl-breadcrumbs aria-label=Breadcrumb><ol class=vl-breadcrumbs-list><li class=vl-breadcrumbs-item><a href=https://eliasjudin.github.io/>Elias Judin</a></li><li class=vl-breadcrumbs-item><a href=https://eliasjudin.github.io/blog/>Blog</a></li><li class=vl-breadcrumbs-item><span aria-current=page>M-sets and Yoneda for monoids</span></li></ol></nav><header class=vl-section-header><h1 class="vl-section-heading p-name">M-sets and Yoneda for monoids</h1><p class=vl-section-meta><time class=dt-published datetime=2022-07-15>15 Jul 2022</time></p><p class=vl-section-meta><time class=dt-updated datetime=2025-12-25>Updated 25 Dec 2025</time></p></header><div class="vl-section-body vl-single e-content"><p>The Yoneda lemma says that for a category <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math>, an object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math>, and a functor <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>:</mo><mi mathvariant="double-struck">C</mi><mo>→</mo><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">S:\mathbb{C}\to\textbf{Sets}</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><mo>−</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{Nat}(\operatorname{hom}(C,-),S)</annotation></semantics></math> is in bijection with <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(C)</annotation></semantics></math>. These bijections are given by <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>:</mo><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><mo>−</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>→</mo><mi>S</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha: \operatorname{Nat}(\operatorname{hom}(C,-),S)\to S(C)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>:</mo><mi>S</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mo>→</mo><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><mo>−</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\beta: S(C) \to \operatorname{Nat}(\operatorname{hom}(C,-),S)</annotation></semantics></math> defined as <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>σ</mi><mi>C</mi></msub><mo stretchy="false">(</mo><msub><mn>1</mn><mi>C</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha(\sigma)=\sigma_ {C}(1_ {C})</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo stretchy="false">(</mo><mi>c</mi><msub><mo stretchy="false">)</mo><mi>A</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mi>S</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\beta(c)_ {A}(f)=S(f)(c)</annotation></semantics></math><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. This is the covariant form of the Yoneda lemma. There is also a contravariant form that specifies the bijective correspondence <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>≈</mo><mi>S</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{Nat}(\operatorname{hom}(-,C),S)\approx S(C)</annotation></semantics></math>. Setting <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S=\operatorname{hom}(-,C&#x27;)</annotation></semantics></math>, the Yoneda lemma tells us that natural transformations between the functors <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(-,C)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(-,C&#x27;)</annotation></semantics></math> are in bijection with elements of the set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(C,C&#x27;)</annotation></semantics></math>.</p><hr><p>Let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> be a monoid, then a left <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi></mrow><annotation encoding="application/x-tex">\mathcal{X}</annotation></semantics></math> is an object in the functor category <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant="bold">Sets</mtext><mi>M</mi></msup></mrow><annotation encoding="application/x-tex">\textbf{Sets}^M</annotation></semantics></math><sup id=fnref1:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. Let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi><mo>:</mo><mi>M</mi><mo>→</mo><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\mathcal{X}:M\to\textbf{Sets}</annotation></semantics></math> be a covariant functor then <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi></mrow><annotation encoding="application/x-tex">\mathcal{X}</annotation></semantics></math> specifies an object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\textbf{Sets}</annotation></semantics></math>, the image of the unique object of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> under <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi></mrow><annotation encoding="application/x-tex">\mathcal{X}</annotation></semantics></math>, together with an endomorphism <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo>:</mo><mi>X</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\mathcal{X}(u):X\to X</annotation></semantics></math> for each morphism <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> (i.e. an element of the monoid <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>) that maps <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>↦</mo><mi>u</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">x\mapsto ux</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mi mathvariant="script">X</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="script">X</mi><mo stretchy="false">(</mo><mi>u</mi><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{X}(u)\mathcal{X}(v)=\mathcal{X}(uv)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mn>1</mn><mi>X</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{X}(e)=1_ {X}</annotation></semantics></math>. Similarly, a contravariant functor <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi><mo>:</mo><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>→</mo><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\mathcal{X}:M^{op}\to\textbf{Sets}</annotation></semantics></math> is a right <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set (or equivalently, an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">M^{op}</annotation></semantics></math>-set), but must instead satisfy <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi><mo stretchy="false">(</mo><mi>v</mi><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="script">X</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mi mathvariant="script">X</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{X}(vu) = \mathcal{X}(u)\mathcal{X}(v)</annotation></semantics></math>. When we refer to &ldquo;<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-sets&rdquo; we mean left <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-sets.</p><p>The monoid <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> itself is an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set. Since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>, viewed as a category, has only a single object, the set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}_  {M}(\{M\},\{M\})</annotation></semantics></math> is the set of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set endomorphisms of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{M\}</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> and so <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>=</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {M}(\{M\},\{M\})=M</annotation></semantics></math>. Note that the set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {M}(\{M\},\{M\})</annotation></semantics></math> inherits the monoid structure from the properties of composition of morphisms in a category. The covariant functor <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo>−</mo><mo stretchy="false">)</mo><mo>:</mo><mi>M</mi><mo>→</mo><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {M}(\{M\},-):M\to \textbf{Sets}</annotation></semantics></math> is a <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U(M)</annotation></semantics></math> (where <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>:</mo><mtext mathvariant="bold">Mon</mtext><mo>→</mo><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">U:\textbf{Mon}\to\textbf{Sets}</annotation></semantics></math> is the forgetful functor) with <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> acting on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U(M)</annotation></semantics></math> by left multiplication since for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">u\in M</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>:</mo><mi>M</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {M}(\{M\},u):M\to M</annotation></semantics></math> is defined by <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>u</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {M}(\{M\},u)(x)=ux</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">x\in M</annotation></semantics></math>. Similarly, the contravariant functor <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>:</mo><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>→</mo><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {M}(-,\{M\}):M^{op}\to \textbf{Sets}</annotation></semantics></math> is a <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U(M)</annotation></semantics></math> with <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> acting on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U(M)</annotation></semantics></math> by right multiplication. As a result, we denote the <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U(M)</annotation></semantics></math> as <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>.</p><hr><p>Consider an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>:</mo><mi>M</mi><mo>→</mo><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">S:M\to \textbf{Sets}</annotation></semantics></math>, then a natural transformation <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo>:</mo><mi>M</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">\tau : M \to S</annotation></semantics></math> is an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set homomorphism from <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math><sup id=fnref2:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. The map <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo>:</mo><mi>M</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">\tau : M\to S</annotation></semantics></math> is the unique component of the natural transformation. The naturality condition is satisfied since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math> is a <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set homomorphism, that is, for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math> a morphism in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>,</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>τ</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>τ</mi><mo stretchy="false">(</mo><mi>u</mi><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>u</mi><mi>τ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>S</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>τ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\tau (M(u)(x))=\tau (ux)=u\tau (x)=S(u)(\tau (x))</annotation></semantics></math><p>for all <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">x\in M</annotation></semantics></math>.</p><p>Now, we can form the set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><mi>M</mi></msup></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {\textbf{Sets}^M}(M,S)</annotation></semantics></math> which consists of morphisms <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">M\to S</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-sets (i.e. <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set homomorphisms). These morphisms are natural transformations of the functors <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math>, so</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><mi>M</mi></msup></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo>−</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {\textbf{Sets}^M}(M,S)=\operatorname{Nat}(M,S)=\operatorname{Nat}(\operatorname{hom}_ {M}(\{M\},-),S)</annotation></semantics></math><p>since we can represent <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> with the functor <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo>−</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {M}(\{M\},-)</annotation></semantics></math> as every monoid acts on itself by left or right multiplication. Hence by the Yoneda lemma,</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><mi>M</mi></msup></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo>−</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>≈</mo><mi>S</mi><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>=</mo><mi>S</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {\textbf{Sets}^M}(M,S) = \operatorname{Nat}(\operatorname{hom}_ {M}(\{M\},-),S)\approx S(\{M\})=S.</annotation></semantics></math><p>We have proved the following result,</p><blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set homomorphisms <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">M\to S</annotation></semantics></math> correspond bijectively to elements of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math>.</p></blockquote><p>This bijection is given by the maps <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>:</mo><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><mi>M</mi></msup></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">\alpha:\operatorname{hom}_ {\textbf{Sets}^M}(M,S)\to S</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>:</mo><mi>S</mi><mo>→</mo><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><mi>M</mi></msup></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\beta:S\to\operatorname{hom}_ {\textbf{Sets}^M}(M,S)</annotation></semantics></math> defined by</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">)</mo><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mtext> and,</mtext></mrow><annotation encoding="application/x-tex">\alpha(\sigma)=\sigma(e)\text{ and,}</annotation></semantics></math><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>β</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>S</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\beta(s)(x)=S(x)(s)=xs.</annotation></semantics></math><p>They are inverse to each other since</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mi>β</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>β</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><mi>e</mi><mi>s</mi><mo>=</mo><mi>s</mi><mtext> and,</mtext></mrow><annotation encoding="application/x-tex">\alpha(\beta(s)(x))=\beta(s)(e)=es=s\text{ and,}</annotation></semantics></math><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>β</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>S</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mi>α</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mi>σ</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>x</mi><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\beta(\alpha(\sigma))(x)=S(x)(\alpha(\sigma))=x\alpha(\sigma)=x\sigma(e)=\sigma(xe)=\sigma(x).</annotation></semantics></math><p>We can interpret this bijection as follows, the choice of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma(e)</annotation></semantics></math> determines every other value <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma(x)</annotation></semantics></math> for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">x\in M</annotation></semantics></math> since</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>x</mi><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mi>σ</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma(x)=\sigma(xe)=x\sigma(e)</annotation></semantics></math><p>as <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math> is an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set homomorphism<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</p><p><em>Cayley&rsquo;s Theorem</em> arises as a special case of the above result. For a group <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math>, set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mi>S</mi><mo>=</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">M=S=G</annotation></semantics></math> then we have that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mi>G</mi><mo stretchy="false">)</mo><mo>≈</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}(G,G)\approx G</annotation></semantics></math><p>and since the set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(G,G)</annotation></semantics></math> contains automorphisms of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math>, it is a subgroup of the group of all permutations on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math>.</p><hr><p>There is a counterpart to the bijection <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>≈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}(M,S)\approx S</annotation></semantics></math> in linear algebra. Consider a field <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">K</mi></mrow><annotation encoding="application/x-tex">\mathbb{K}</annotation></semantics></math> and a <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">K</mi></mrow><annotation encoding="application/x-tex">\mathbb{K}</annotation></semantics></math>-vector space <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>, then <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="double-struck">K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo>≈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}(\mathbb{K},V)\approx V</annotation></semantics></math>. This bijection is given by <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>:</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="double-struck">K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\alpha:\operatorname{hom}(\mathbb{K},V)\to V</annotation></semantics></math> defined as <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">)</mo><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha(\sigma)=\sigma(1)</annotation></semantics></math>. The map <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math> is clearly linear and injective. To see that it is surjective, notice that for any <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v\in V</annotation></semantics></math>, there is a map <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>∈</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="double-struck">K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma\in\operatorname{hom}(\mathbb{K},V)</annotation></semantics></math> that maps the multiplicative identity <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math> onto <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math>, namely, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">\sigma(k)=kv</annotation></semantics></math>. The inverse map <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>:</mo><mi>V</mi><mo>→</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="double-struck">K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\beta:V\to\operatorname{hom}(\mathbb{K},V)</annotation></semantics></math> is given by <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">\beta(v)(k)=kv</annotation></semantics></math>, and we have that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mi>β</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>β</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mi>v</mi><mo>=</mo><mi>v</mi><mtext> and,</mtext></mrow><annotation encoding="application/x-tex">\alpha(\beta(v)(k))=\beta(v)(1)=1v=v\text{ and,}</annotation></semantics></math><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>β</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mi>β</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mi>σ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\beta(\alpha(\sigma))(k)=\beta(\sigma(1))(k)=k\sigma(1)=\sigma(k).</annotation></semantics></math><p>However, we are not able to obtain this result from the Yoneda lemma as it has been formulated here. A stronger result, the <em>enriched Yoneda lemma</em>, is required<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><hr><p>Let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> be a category, then the Yoneda embedding is the functor <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>:</mo><mi mathvariant="double-struck">C</mi><mo>→</mo><msup><mtext mathvariant="bold">Sets</mtext><msup><mi mathvariant="double-struck">C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></mrow><annotation encoding="application/x-tex">Y:\mathbb{C}\to\textbf{Sets}^{\mathbb{C}^{op}}</annotation></semantics></math> that maps every object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> to the functor <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mo>:</mo><msup><mi mathvariant="double-struck">C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>→</mo><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\operatorname{hom}(-,C):\mathbb{C}^{op}\to\textbf{Sets}</annotation></semantics></math> and every morphism <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>:</mo><mi>C</mi><mo>→</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">c:C\to C&#x27;</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> to the natural transformation <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mo>:</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mo>→</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(-,c):\operatorname{hom}(-,C)\to\operatorname{hom}(-,C&#x27;)</annotation></semantics></math>, where each component of the natural transformation is defined by <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>c</mi><msub><mo stretchy="false">)</mo><mi>A</mi></msub><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(-,c)_ {A}=\operatorname{hom}(A,c)</annotation></semantics></math> for each object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> (i.e. postcomposition with <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math>). The Yoneda embedding is fully faithful which follows from the Yoneda lemma<sup id=fnref3:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. This means that the functor <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> preserves the relationships that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> shares with every other object in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> and so <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> fully faithfully embeds <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> into <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi mathvariant="double-struck">C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></mrow><annotation encoding="application/x-tex">\textbf{Sets}^{\mathbb{C}^{op}}</annotation></semantics></math>. That is, for every natural transformation <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo>:</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mo>→</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\tau:\operatorname{hom}(-,C)\to\operatorname{hom}(-,C&#x27;)</annotation></semantics></math> there is exactly one morphism <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>:</mo><mi>C</mi><mo>→</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">c:C\to C&#x27;</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mo>=</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}(-,c)=\tau</annotation></semantics></math>. Using this embedding, we are able to work with any category <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> by embedding it in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi mathvariant="double-struck">C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></mrow><annotation encoding="application/x-tex">\textbf{Sets}^{\mathbb{C}^{op}}</annotation></semantics></math> which, in general, has `nicer&rsquo; properties and is easier to work with<sup id=fnref1:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><p>We are able to obtain the Yoneda embedding by using the Yoneda lemma in the case where <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S=\operatorname{hom}(-,C&#x27;)</annotation></semantics></math> for some object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">C&#x27;</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> since the Yoneda lemma says that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{Nat}(\operatorname{hom}(-,C),\operatorname{hom}(-,C&#x27;))</annotation></semantics></math> is in bijection with <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(C,C&#x27;)</annotation></semantics></math>, which is exactly the Yoneda embedding which assigns to each morphism <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>:</mo><mi>C</mi><mo>→</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">c:C\to C&#x27;</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> the natural transformation <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(-,c)</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi mathvariant="double-struck">C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></mrow><annotation encoding="application/x-tex">\textbf{Sets}^{\mathbb{C}^{op}}</annotation></semantics></math>.</p><p>Since the Yoneda embedding <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> fully faithfully embeds <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> into <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi mathvariant="double-struck">C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></mrow><annotation encoding="application/x-tex">\textbf{Sets}^{\mathbb{C}^{op}}</annotation></semantics></math>, we have that, for any two objects <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">C&#x27;</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math>,</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">(</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Nat</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≈</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{Nat}(Y(C),Y(C&#x27;))=\operatorname{Nat}(\operatorname{hom}(-,C),\operatorname{hom}(-,C&#x27;))\approx \operatorname{hom}(C,C&#x27;)</annotation></semantics></math><p>and hence, there is a relationship <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi><mo>⟷</mo><msup><mtext mathvariant="bold">Sets</mtext><msup><mi mathvariant="double-struck">C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup><mo>⟷</mo><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\mathbb{C}\longleftrightarrow\textbf{Sets}^{\mathbb{C}^{op}}\longleftrightarrow\textbf{Sets}</annotation></semantics></math> that allows us to characterise an object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> by its relationships to all other objects <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">C&#x27;</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math>. That is, the properties of any object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> are encoded in the sets <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(C,C&#x27;)</annotation></semantics></math> for each <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">C&#x27;</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math>.</p><hr><p>Let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>M</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{M}</annotation></semantics></math> be the monoid of all maps <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">M\to M</annotation></semantics></math> (not just monoid homomorphisms) and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>M</mi><mo>→</mo><mover accent="true"><mi>M</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">f:M\to\hat{M}</annotation></semantics></math> map each <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">x\in M</annotation></semantics></math> to the map <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>:</mo><mi>M</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">f(x):M\to M</annotation></semantics></math> defined by <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">f(x)(y)=xy</annotation></semantics></math>. Let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>:</mo><mi>M</mi><mo>→</mo><msup><mtext mathvariant="bold">Sets</mtext><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></mrow><annotation encoding="application/x-tex">Y: M\to\textbf{Sets}^{M^{op}}</annotation></semantics></math> be the Yoneda embedding of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> into <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></mrow><annotation encoding="application/x-tex">\textbf{Sets}^{M^{op}}</annotation></semantics></math>. Then <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x) = \operatorname{hom}(\{M\},x) = \operatorname{hom}(-,x)=Y(x)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>=</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">Y(\{M\})=\operatorname{hom}(-,\{M\})=\operatorname{hom}(\{M\},\{M\})=M</annotation></semantics></math> since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> is a single object category. Now, since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> is fully faithful, the induced functor,</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>Y</mi><mrow><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo></mrow></msub><mo>:</mo><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>→</mo><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y_ {\{M\},\{M\}}:\operatorname{hom}_ {M}(\{M\},\{M\})\to\operatorname{hom}_ {\textbf{Sets}^{M^{op}}}(Y(\{M\}),Y(\{M\}))</annotation></semantics></math><p>is bijective. But, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mi>M</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>=</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {M}(\{M\},\{M\})=M</annotation></semantics></math> and</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">)</mo><mo>⊂</mo><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><mtext mathvariant="bold">Sets</mtext></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">)</mo><mo>=</mo><mover accent="true"><mi>M</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {\textbf{Sets}^{M^{op}}}(Y(\{M\}),Y(\{M\}))=\operatorname{hom}_ {\textbf{Sets}^{M^{op}}}(M,M)\subset\operatorname{hom}_ {\textbf{Sets}}(M,M) = \hat{M}</annotation></semantics></math><p>since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y(\{M\})</annotation></semantics></math> is the <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">M^{op}</annotation></semantics></math>-set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U(M)</annotation></semantics></math> which is <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> viewed as a right <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set. So we have that the induced functor</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>Y</mi><mrow><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo></mrow></msub><mo>:</mo><mi>M</mi><mo>→</mo><mover accent="true"><mi>M</mi><mo>^</mo></mover><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">Y_ {\{M\},\{M\}}:M\to\hat{M},</annotation></semantics></math><p>defined by <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mrow><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>M</mi><mo stretchy="false">}</mo></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y_ {\{M\},\{M\}}(x) =Y(x)= f(x)</annotation></semantics></math>, is bijective onto <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {\textbf{Sets}^{M^{op}}}(M,M)</annotation></semantics></math>. However, it is only injective into <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>M</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{M}</annotation></semantics></math>. Now, since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>u</mi><mi>v</mi><mo stretchy="false">)</mo><mi>y</mi><mo>=</mo><mi>u</mi><mo stretchy="false">(</mo><mi>v</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>v</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(uv)(y)=(uv)y=u(vy)=f(u)(vy)=f(u)f(v)(y)</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>M</mi><mo>→</mo><mover accent="true"><mi>M</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">f:M\to\hat{M}</annotation></semantics></math> is an injective homomorphism of monoids. The image of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> is the image of the induced functor which is just the set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo></mrow><msup><mtext mathvariant="bold">Sets</mtext><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msup></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}_ {\textbf{Sets}^{M^{op}}}(M,M)</annotation></semantics></math> of all <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">M^{op}</annotation></semantics></math>-set homomorphisms from <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> (or equivalently, right <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>-set homomorphisms from <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>).</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>George Janelidze. Category theory: A first course. Lecture Notes, 2020.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref2:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref3:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Emily Riehl. <em>Category theory in context</em>. Dover Publications, 2017.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>George Janelidze. Conversation on yoneda lemma. Personal communication 07/06/22, 2022.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div><footer class=vl-single-footer><p class="vl-section-meta vl-single-tags"><span class=vl-single-tags-label>Tags:</span>
<a class=p-category href=/tags/category-theory/ rel=tag>Category theory</a></p></footer></div></article></div></main><footer class=vl-footer role=contentinfo><div class=vl-footer-note>© 2025 by Elias Judin</div></footer></div></div></body></html>