<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Modules and Vector Spaces as Algebraic Categories — Elias Judin</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Exercises in category theory: category of modules and category of vector spaces as algebraic categories"><meta name=theme-color content="#ffffff"><meta name=author content="Elias Judin"><link rel=canonical href=https://eliasjudin.github.io/blog/category_of_modules_and_vector_spaces_as_algebraic_categories/><meta property="og:url" content="https://eliasjudin.github.io/blog/category_of_modules_and_vector_spaces_as_algebraic_categories/"><meta property="og:title" content="Modules and Vector Spaces as Algebraic Categories — Elias Judin"><meta property="og:description" content="Exercises in category theory: category of modules and category of vector spaces as algebraic categories"><meta property="og:type" content="article"><meta property="og:site_name" content="Elias Judin"><meta property="og:image" content="https://eliasjudin.github.io/assets/images/banner-social.png"><meta property="og:image:alt" content="Modules and Vector Spaces as Algebraic Categories — Elias Judin"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Modules and Vector Spaces as Algebraic Categories — Elias Judin"><meta name=twitter:description content="Exercises in category theory: category of modules and category of vector spaces as algebraic categories"><meta name=twitter:image content="https://eliasjudin.github.io/assets/images/banner-social.png"><meta name=twitter:image:alt content="Modules and Vector Spaces as Algebraic Categories — Elias Judin"><link rel=alternate type=application/rss+xml title="Elias Judin" href=https://eliasjudin.github.io/index.xml><meta property="article:published_time" content="2022-06-26T18:56:48+02:00"><meta property="article:modified_time" content="2022-06-26T18:56:48+02:00"><link rel=icon type=image/svg+xml href=/favicon.svg><link rel=stylesheet href=/css/style.min.54f2e90d4cbccadbcce9e77c703c77723bb46523756fb9ea7e9781f7816924e7.css integrity="sha256-VPLpDUy8ytvM6ed8cDx3cju0ZSN1b7nqfpeB94FpJOc="><script type=application/ld+json>[{"@context":"https://schema.org","@type":"WebSite","description":"Exercises in category theory: category of modules and category of vector spaces as algebraic categories","inLanguage":"en","name":"Elias Judin","publisher":{"@type":"Person","name":"Elias Judin"},"url":"https://eliasjudin.github.io/"},{"@context":"https://schema.org","@type":"Article","author":{"@type":"Person","name":"Elias Judin"},"dateModified":"2022-06-26T18:56:48+02:00","datePublished":"2022-06-26T18:56:48+02:00","description":"Exercises in category theory: category of modules and category of vector spaces as algebraic categories","headline":"Modules and Vector Spaces as Algebraic Categories","image":"https://eliasjudin.github.io/assets/images/banner-social.png","url":"https://eliasjudin.github.io/blog/category_of_modules_and_vector_spaces_as_algebraic_categories/"}]</script><meta name=generator content="Hugo 0.150.0"></head><body><a class=vl-skip-link href=#main>Skip to main content</a><div class=vl-page><div class=vl-frame><header class=vl-header role=banner><div class=vl-top><div><form class=vl-top-form aria-label="Navigate site"><label class=vl-sr-only for=vl-top-select>Navigate to page</label>
<select id=vl-top-select class=vl-top-select onchange="this.value&&(window.location.href=this.value)"><option value disabled>Navigate...</option><option value=/>home</option><option value=/blog selected>mathematics blog</option><option value=/log>latest notes</option><option value=/timeline>timeline</option><option value=/cv>curriculum vitae</option><option value disabled>..................................................</option><option value=/contact>contact</option><option value=https://github.com/eliasjudin>github</option><option value=https://za.linkedin.com/in/elias-judin-a6988325a>linkedin</option></select></form><nav class=vl-sr-only aria-label="Primary site navigation"><ul><li><a href=/>home</a></li><li><a href=/blog aria-current=page>mathematics blog</a></li><li><a href=/log>latest notes</a></li><li><a href=/timeline>timeline</a></li><li><a href=/cv>curriculum vitae</a></li><li><a href=/contact>contact</a></li><li><a href=https://github.com/eliasjudin>github</a></li><li><a href=https://za.linkedin.com/in/elias-judin-a6988325a>linkedin</a></li></ul></nav></div><div class=vl-top-title><a href=/ class=vl-top-title-link>Elias Judin</a></div></div><div class=vl-tickers role=presentation><div class=vl-ticker data-speed=medium><span class=vl-sr-only>Elias Judin, Category theory, Universal algebra</span><div class=vl-ticker-track aria-hidden=true>&nbsp;: Elias Judin : Category theory : Universal algebra :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: Elias Judin : Category theory : Universal algebra :&nbsp;&nbsp;&nbsp;&nbsp;</div></div><div class=vl-ticker data-speed=fast><span class=vl-sr-only>Lean4 @ Harmonic, Project Numina labeling, UCT category seminars, UCT grant 2024</span><div class=vl-ticker-track aria-hidden=true>&nbsp;:: Lean4 @ Harmonic :: Project Numina labeling :: UCT category seminars :: UCT grant 2024 ::&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: Lean4 @ Harmonic :: Project Numina labeling :: UCT category seminars :: UCT grant 2024 ::&nbsp;&nbsp;&nbsp;&nbsp;</div></div><div class=vl-ticker data-speed=slow><span class=vl-sr-only>University of Cape Town, Harmonic, Project Numina, Category Theory Group</span><div class=vl-ticker-track aria-hidden=true>&nbsp;::: University of Cape Town ::: Harmonic ::: Project Numina ::: Category Theory Group :::&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::: University of Cape Town ::: Harmonic ::: Project Numina ::: Category Theory Group :::&nbsp;&nbsp;&nbsp;&nbsp;</div></div></div></header><main id=main class=vl-main><div class="vl-section vl-section--post"><article class=vl-section-inner><header class=vl-section-header><h1 class=vl-section-heading><strong>Modules and Vector Spaces as Algebraic Categories</strong></h1><p class=vl-section-meta><time datetime=2022-06-26>26 Jun 2022</time></p></header><div class="vl-section-body vl-single"><p>An algebraic category is defined to be any full subcategory of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">Alg</mtext><mo stretchy="false">(</mo><mi mathvariant="normal">Ω</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\textbf{Alg}(\Omega)</annotation></semantics></math>, the category of all <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math>-algebras. We can define various algebraic structures as algebraic categories. For example, in order to define <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">Groups</mtext></mrow><annotation encoding="application/x-tex">\textbf{Groups}</annotation></semantics></math>, the category of Groups, we can specify <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi><mo>=</mo><mspace linebreak="newline"></mspace><mrow><mi>e</mi><mo separator="true">,</mo><mi>m</mi><mo separator="true">,</mo><mi>i</mi><mspace linebreak="newline"></mspace></mrow></mrow><annotation encoding="application/x-tex">\Omega = \\{e,m,i\\}</annotation></semantics></math> as the set consisting of three operators: one nullary, one unary, and one binary, such that, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mi>e</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(G,e,m)</annotation></semantics></math> is a monoid and</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mo>=</mo><mi>m</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(i(x),x)=x=m(x,(i(x))</annotation></semantics></math><p><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo>∈</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">\forall x \in G</annotation></semantics></math>, making <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">Alg</mtext><mo stretchy="false">(</mo><mi mathvariant="normal">Ω</mi><mo stretchy="false">)</mo><mo>=</mo><mtext mathvariant="bold">Groups</mtext></mrow><annotation encoding="application/x-tex">\textbf{Alg}(\Omega) = \textbf{Groups}</annotation></semantics></math> for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math> as specified<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. However, an issue arises when considering vector spaces over a field and modules over a ring as the operators in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math> are defined to act on the elements of the underlying set, and not on elements outside of that set, say in a field or a ring. This issue arises when trying to define scalar multiplication for these structures. Consider a vector space <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> over a field <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math>. We define a binary operator <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math> on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> called multiplication, then <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>:</mo><msup><mi>V</mi><mn>2</mn></msup><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v(m):V^2\to V</annotation></semantics></math>, where</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>v</mi><mo>:</mo><mi mathvariant="normal">Ω</mi><mo>→</mo><munder><mo>⋃</mo><mrow><mi>n</mi><mo>∈</mo><mi mathvariant="bold">N</mi></mrow></munder><msup><mi>V</mi><msup><mi>V</mi><mi>n</mi></msup></msup></mrow><annotation encoding="application/x-tex">v: \Omega \to \bigcup_{n \in \mathbf{N}} V^{V^{n}}</annotation></semantics></math><p>for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">N</mi></mrow><annotation encoding="application/x-tex">\mathbf{N}</annotation></semantics></math> the natural numbers<sup id=fnref1:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. Now there is an issue since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math> is not defined to operate on the elements of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math>. What follows is an explanation as to how we can get around this issue and define vector spaces over a field <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math> and modules over a ring <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math> as algebraic categories.</p><hr><p>We start with <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math>-modules. Let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math> be a commutative ring with <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> the underlying set of the module. Define the signature <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>M</mi></msub><mo>=</mo><mspace linebreak="newline"></mspace><mrow><msub><mi>a</mi><mi>M</mi></msub><mo separator="true">,</mo><msub><mn>0</mn><mi>M</mi></msub><mo separator="true">,</mo><msub><mi>i</mi><mi>M</mi></msub><mspace linebreak="newline"></mspace></mrow></mrow><annotation encoding="application/x-tex">\Omega_M = \\{a_M,0_M,i_M\\}</annotation></semantics></math> where <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">a_M</annotation></semantics></math> is a commutative associative binary operator on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mn>0</mn><mi>M</mi></msub><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">0_M\in M</annotation></semantics></math> is a nullary operator such that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>a</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><msub><mn>0</mn><mi>M</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>u</mi><mo>=</mo><msub><mi>a</mi><mi>M</mi></msub><mo stretchy="false">(</mo><msub><mn>0</mn><mi>M</mi></msub><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a_M(u,0_M)=u=a_M(0_M,u)</annotation></semantics></math><p><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>u</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\forall u\in M</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">i_M</annotation></semantics></math> is an unary operator on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> such that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>a</mi><mi>M</mi></msub><mo stretchy="false">(</mo><msub><mi>i</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mn>0</mn><mi>M</mi></msub><mo>=</mo><msub><mi>a</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><msub><mi>i</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a_M(i_M(u),u)=0_M=a_M(u,i_M(u))</annotation></semantics></math><p><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>u</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\forall u\in M</annotation></semantics></math>.
Now, in order to define scalar multiplication, we define the signature <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>R</mi></msub><mo>=</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">\Omega_R = R</annotation></semantics></math> where each element of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math> is considered as a unary operator on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>. However, we need to add some structure to <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">\Omega_R</annotation></semantics></math> since, in a ring, we are able to add and multiply elements of the ring to get new elements in the ring. To do this, we define a signature for an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math>-algebra on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">\Omega_R</annotation></semantics></math> by <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="normal">Ω</mi><mi>R</mi><mtext>ring</mtext></msubsup><mo>=</mo><mspace linebreak="newline"></mspace><mrow><mi>a</mi><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mi>i</mi><mo separator="true">,</mo><mi>m</mi><mo separator="true">,</mo><mn>1</mn><mspace linebreak="newline"></mspace></mrow></mrow><annotation encoding="application/x-tex">\Omega_{R}^{\text{ring}} = \\{a,0,i,m,1\\}</annotation></semantics></math> with the same properties as the operators in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">\Omega_M</annotation></semantics></math> above for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">a,0,i</annotation></semantics></math> and additionally, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math> is an associative binary operator on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">\Omega_R</annotation></semantics></math> such that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(r,a(s,t)) = a(m(r,s),m(r,t))</annotation></semantics></math><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(a(r,s),t) = a(m(r,t),m(s,t))</annotation></semantics></math><p><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>r</mi><mo separator="true">,</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo>∈</mo><msub><mi mathvariant="normal">Ω</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">\forall r,s,t\in \Omega_R</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∈</mo><msub><mi mathvariant="normal">Ω</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">1\in \Omega_R</annotation></semantics></math> is a nullary operator such that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>r</mi><mo>=</mo><mi>m</mi><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(r,1)=r=m(1,r)</annotation></semantics></math><p><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>r</mi><mo>∈</mo><msub><mi mathvariant="normal">Ω</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">\forall r\in \Omega_R</annotation></semantics></math>. We can then make <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><msub><mi>h</mi><mi>M</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M=(M,h_M)</annotation></semantics></math> into an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">\Omega_R</annotation></semantics></math>-set (as in Example 3.10) by defining the map <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>M</mi></msub><mo>:</mo><msub><mi mathvariant="normal">Ω</mi><mi>R</mi></msub><mo>×</mo><mi>M</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">h_M:\Omega_R\times M\to M</annotation></semantics></math> as <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mi>ω</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">h_M(\omega,p)=\omega p</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>p</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\forall p \in M</annotation></semantics></math> <sup id=fnref2:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. However, we require additional properties for the map <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">h_M</annotation></semantics></math>:</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>h</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><mi>u</mi></mrow><annotation encoding="application/x-tex">h_M(1,u)=u</annotation></semantics></math><p></p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>h</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mi>a</mi><mi>M</mi></msub><mo stretchy="false">(</mo><msub><mi>h</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>h</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_M(\omega,a_M(u,v)) = a_M(h_M(\omega,u),h_M(\omega,v))</annotation></semantics></math><p></p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>h</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><msup><mi>ω</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>a</mi><mi>M</mi></msub><mo stretchy="false">(</mo><msub><mi>h</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>h</mi><mi>M</mi></msub><mo stretchy="false">(</mo><msup><mi>ω</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_M(a(\omega,\omega^{\prime}),u)=a_M(h_M(\omega,u),h_M(\omega^{\prime},u))</annotation></semantics></math><p></p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>h</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><msup><mi>ω</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>h</mi><mi>M</mi></msub><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><msub><mi>h</mi><mi>M</mi></msub><mo stretchy="false">(</mo><msup><mi>ω</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_M(m(\omega,\omega^{\prime}),u)=h_M(\omega , h_M(\omega^{\prime},u))</annotation></semantics></math><p><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>ω</mi><mo separator="true">,</mo><msup><mi>ω</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∈</mo><msub><mi mathvariant="normal">Ω</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">\forall \omega,\omega^{\prime}\in\Omega_R</annotation></semantics></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\forall u,v\in M</annotation></semantics></math>. In this way, scalar multiplication of an element of M by one of R is defined using the map <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">h_M</annotation></semantics></math>. So by letting the signature of the <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math>-module be <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi><mo>=</mo><msub><mi mathvariant="normal">Ω</mi><mi>R</mi></msub><mo>∪</mo><msub><mi mathvariant="normal">Ω</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">\Omega = \Omega_R \cup \Omega_ M</annotation></semantics></math>, we obtain <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">Alg</mtext><mo stretchy="false">(</mo><mi mathvariant="normal">Ω</mi><mo stretchy="false">)</mo><mo>=</mo><mtext mathvariant="bold">Modules</mtext></mrow><annotation encoding="application/x-tex">\textbf{Alg}(\Omega)=\textbf{Modules}</annotation></semantics></math>, showing <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">Modules</mtext></mrow><annotation encoding="application/x-tex">\textbf{Modules}</annotation></semantics></math> is an algebraic category.</p><hr><p>Similarly, for a vector space <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> over a field <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math> we can define a signature <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>V</mi></msub><mo>=</mo><mspace linebreak="newline"></mspace><mrow><msub><mi>a</mi><mi>V</mi></msub><mo separator="true">,</mo><msub><mn>0</mn><mi>V</mi></msub><mo separator="true">,</mo><msub><mi>i</mi><mi>V</mi></msub><mspace linebreak="newline"></mspace></mrow></mrow><annotation encoding="application/x-tex">\Omega_V = \\{a_V,0_V,i_V\\}</annotation></semantics></math> where <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>V</mi></msub></mrow><annotation encoding="application/x-tex">a_V</annotation></semantics></math> is a commutative associative binary operator on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mn>0</mn><mi>V</mi></msub><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">0_V\in V</annotation></semantics></math> is a nullary operator such that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>a</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><msub><mn>0</mn><mi>V</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>u</mi><mo>=</mo><msub><mi>a</mi><mi>V</mi></msub><mo stretchy="false">(</mo><msub><mn>0</mn><mi>V</mi></msub><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a_V(u,0_V)=u=a_V(0_V,u)</annotation></semantics></math><p><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>u</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\forall u\in V</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mi>V</mi></msub></mrow><annotation encoding="application/x-tex">i_V</annotation></semantics></math> is an unary operator on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> such that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>a</mi><mi>V</mi></msub><mo stretchy="false">(</mo><msub><mi>i</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mo>=</mo><msub><mi>a</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><msub><mi>i</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a_V(i_V(u),u)=0=a_V(u,i_V(u))</annotation></semantics></math><p><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>u</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\forall u\in V</annotation></semantics></math>.
To define scalar multiplication of elements of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> by those of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math>, we define the signature <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>K</mi></msub><mo>=</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">\Omega_K = K</annotation></semantics></math> in which each element of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math> is a unary operator on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>. We add a field structure to <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">\Omega_K</annotation></semantics></math> by defining a signature for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">\Omega_K</annotation></semantics></math> as <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="normal">Ω</mi><mi>K</mi><mtext>field</mtext></msubsup><mo>=</mo><mspace linebreak="newline"></mspace><mrow><mi>a</mi><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>i</mi><mi>a</mi></msub><mo separator="true">,</mo><mi>m</mi><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>i</mi><mi>m</mi></msub><mspace linebreak="newline"></mspace></mrow></mrow><annotation encoding="application/x-tex">\Omega_{K}^{\text{field}}=\\{a,0,i_a,m,1,i_m\\}</annotation></semantics></math> with the same properties as the operators in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>V</mi></msub></mrow><annotation encoding="application/x-tex">\Omega_V</annotation></semantics></math> above for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">a,0,i</annotation></semantics></math> and additionally, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math> is a commutative associative binary operator on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">\Omega_K</annotation></semantics></math> such that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">(</mo><mi>d</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(c,a(d,f)) = a(m(c,d),m(c,f))</annotation></semantics></math><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">(</mo><mi>d</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(a(c,d),f) = a(m(c,f),m(d,f))</annotation></semantics></math><p><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo separator="true">,</mo><mi>f</mi><mo>∈</mo><msub><mi mathvariant="normal">Ω</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">\forall c,d,f\in \Omega_K</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∈</mo><msub><mi mathvariant="normal">Ω</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">1\in \Omega_K</annotation></semantics></math> is a nullary operator such that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>c</mi><mo>=</mo><mi>m</mi><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(c,1)=c=m(1,c)</annotation></semantics></math><p><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>c</mi><mo>∈</mo><msub><mi mathvariant="normal">Ω</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">\forall c\in \Omega_K</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">i_m</annotation></semantics></math> is an unary operator on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">\Omega_K</annotation></semantics></math> such that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><msub><mi>i</mi><mi>m</mi></msub><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mo>=</mo><mi>m</mi><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><msub><mi>i</mi><mi>m</mi></msub><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(i_m(c),c)=0=m(c,i_m(c))</annotation></semantics></math><p><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>c</mi><mo>∈</mo><msub><mi mathvariant="normal">Ω</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">\forall c\in \Omega_K</annotation></semantics></math>. Next, make <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><msub><mi>h</mi><mi>V</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V=(V,h_V)</annotation></semantics></math> into an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">\Omega_K</annotation></semantics></math>-set by defining the map <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>V</mi></msub><mo>:</mo><msub><mi mathvariant="normal">Ω</mi><mi>K</mi></msub><mo>×</mo><mi>V</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">h_V:\Omega_K\times V\to V</annotation></semantics></math> as <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><mi>ω</mi><mi>u</mi></mrow><annotation encoding="application/x-tex">h_V(\omega,u)=\omega u</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>u</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\forall u \in V</annotation></semantics></math> with the additional properties that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>h</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mi>a</mi><mi>V</mi></msub><mo stretchy="false">(</mo><msub><mi>h</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>h</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_V(\omega,a_V(u,q))=a_V(h_V(\omega ,u), h_V(\omega ,q))</annotation></semantics></math><p></p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>h</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><msup><mi>ω</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>a</mi><mi>V</mi></msub><mo stretchy="false">(</mo><msub><mi>h</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>h</mi><mi>V</mi></msub><mo stretchy="false">(</mo><msup><mi>ω</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_V(a(\omega,\omega^{\prime}),u) = a_V(h_V(\omega ,u), h_V(\omega^{\prime},u))</annotation></semantics></math><p></p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>h</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><msup><mi>ω</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>h</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mi>ω</mi><mo separator="true">,</mo><msub><mi>h</mi><mi>V</mi></msub><mo stretchy="false">(</mo><msup><mi>ω</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_V(m(\omega,\omega^{\prime}),u) = h_V(\omega ,h_V(\omega^{\prime},u))</annotation></semantics></math><p></p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>h</mi><mi>V</mi></msub><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><mi>u</mi></mrow><annotation encoding="application/x-tex">h_V(1,u) = u</annotation></semantics></math><p><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>ω</mi><mo separator="true">,</mo><msup><mi>ω</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∈</mo><msub><mi mathvariant="normal">Ω</mi><mi>K</mi></msub><mtext>  </mtext><mi mathvariant="normal">∀</mi><mi>u</mi><mo separator="true">,</mo><mi>q</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\forall \omega,\omega^{\prime}\in\Omega_K\;\forall u,q\in V</annotation></semantics></math>. So, for the signature <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi><mo>=</mo><msub><mi mathvariant="normal">Ω</mi><mi>V</mi></msub><mo>∪</mo><msub><mi mathvariant="normal">Ω</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">\Omega = \Omega_ V\cup\Omega_ K</annotation></semantics></math>, we obtain <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">Alg</mtext><mo stretchy="false">(</mo><mi mathvariant="normal">Ω</mi><mo stretchy="false">)</mo><mo>=</mo><mtext mathvariant="bold">Vect</mtext></mrow><annotation encoding="application/x-tex">\textbf{Alg}(\Omega)=\textbf{Vect}</annotation></semantics></math>, showing that the category of vector spaces is an algebraic category.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>George Janelidze, <em>Category theory: A first course</em>, 2020.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref2:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></article></div></main><div class=vl-footer-note>© 2024 by Elias Judin</div></div></div></body></html>