<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Groupoids and skeletons of monoids and preorders — Elias Judin</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Exercises in category theory: groupoids and skeletons"><meta name=theme-color content="#ffffff"><meta name=author content="Elias Judin"><link rel=canonical href=https://eliasjudin.github.io/blog/groupoids_and_skeletons_of_monoids_and_preorders/><meta property="og:url" content="https://eliasjudin.github.io/blog/groupoids_and_skeletons_of_monoids_and_preorders/"><meta property="og:title" content="Groupoids and skeletons of monoids and preorders — Elias Judin"><meta property="og:description" content="Exercises in category theory: groupoids and skeletons"><meta property="og:type" content="article"><meta property="og:site_name" content="Elias Judin"><meta property="og:image" content="https://eliasjudin.github.io/assets/images/banner-social.png"><meta property="og:image:alt" content="Groupoids and skeletons of monoids and preorders — Elias Judin"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Groupoids and skeletons of monoids and preorders — Elias Judin"><meta name=twitter:description content="Exercises in category theory: groupoids and skeletons"><meta name=twitter:image content="https://eliasjudin.github.io/assets/images/banner-social.png"><meta name=twitter:image:alt content="Groupoids and skeletons of monoids and preorders — Elias Judin"><link rel=alternate type=application/rss+xml title="Elias Judin" href=https://eliasjudin.github.io/index.xml><meta property="article:published_time" content="2022-06-14T19:18:00+02:00"><meta property="article:modified_time" content="2022-06-14T19:18:00+02:00"><link rel=icon type=image/svg+xml href=/favicon.svg><link rel=stylesheet href=/css/style.min.54f2e90d4cbccadbcce9e77c703c77723bb46523756fb9ea7e9781f7816924e7.css integrity="sha256-VPLpDUy8ytvM6ed8cDx3cju0ZSN1b7nqfpeB94FpJOc="><script type=application/ld+json>[{"@context":"https://schema.org","@type":"WebSite","description":"Exercises in category theory: groupoids and skeletons","inLanguage":"en","name":"Elias Judin","publisher":{"@type":"Person","name":"Elias Judin"},"url":"https://eliasjudin.github.io/"},{"@context":"https://schema.org","@type":"Article","author":{"@type":"Person","name":"Elias Judin"},"dateModified":"2022-06-14T19:18:00+02:00","datePublished":"2022-06-14T19:18:00+02:00","description":"Exercises in category theory: groupoids and skeletons","headline":"Groupoids and skeletons of monoids and preorders","image":"https://eliasjudin.github.io/assets/images/banner-social.png","url":"https://eliasjudin.github.io/blog/groupoids_and_skeletons_of_monoids_and_preorders/"}]</script><meta name=generator content="Hugo 0.150.0"></head><body><a class=vl-skip-link href=#main>Skip to main content</a><div class=vl-page><div class=vl-frame><header class=vl-header role=banner><div class=vl-top><div><form class=vl-top-form aria-label="Navigate site"><label class=vl-sr-only for=vl-top-select>Navigate to page</label>
<select id=vl-top-select class=vl-top-select onchange="this.value&&(window.location.href=this.value)"><option value disabled>Navigate...</option><option value=/>home</option><option value=/blog selected>mathematics blog</option><option value=/log>latest notes</option><option value=/timeline>timeline</option><option value=/cv>curriculum vitae</option><option value disabled>..................................................</option><option value=/contact>contact</option><option value=https://github.com/eliasjudin>github</option><option value=https://za.linkedin.com/in/elias-judin-a6988325a>linkedin</option></select></form><nav class=vl-sr-only aria-label="Primary site navigation"><ul><li><a href=/>home</a></li><li><a href=/blog aria-current=page>mathematics blog</a></li><li><a href=/log>latest notes</a></li><li><a href=/timeline>timeline</a></li><li><a href=/cv>curriculum vitae</a></li><li><a href=/contact>contact</a></li><li><a href=https://github.com/eliasjudin>github</a></li><li><a href=https://za.linkedin.com/in/elias-judin-a6988325a>linkedin</a></li></ul></nav></div><div class=vl-top-title><a href=/ class=vl-top-title-link>Elias Judin</a></div></div><div class=vl-tickers role=presentation><div class=vl-ticker data-speed=medium><span class=vl-sr-only>Elias Judin, Category theory, Universal algebra</span><div class=vl-ticker-track aria-hidden=true>&nbsp;: Elias Judin : Category theory : Universal algebra :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: Elias Judin : Category theory : Universal algebra :&nbsp;&nbsp;&nbsp;&nbsp;</div></div><div class=vl-ticker data-speed=fast><span class=vl-sr-only>Lean4 @ Harmonic, Project Numina labeling, UCT category seminars, UCT grant 2024</span><div class=vl-ticker-track aria-hidden=true>&nbsp;:: Lean4 @ Harmonic :: Project Numina labeling :: UCT category seminars :: UCT grant 2024 ::&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: Lean4 @ Harmonic :: Project Numina labeling :: UCT category seminars :: UCT grant 2024 ::&nbsp;&nbsp;&nbsp;&nbsp;</div></div><div class=vl-ticker data-speed=slow><span class=vl-sr-only>University of Cape Town, Harmonic, Project Numina, Category Theory Group</span><div class=vl-ticker-track aria-hidden=true>&nbsp;::: University of Cape Town ::: Harmonic ::: Project Numina ::: Category Theory Group :::&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::: University of Cape Town ::: Harmonic ::: Project Numina ::: Category Theory Group :::&nbsp;&nbsp;&nbsp;&nbsp;</div></div></div></header><main id=main class=vl-main><div class="vl-section vl-section--post"><article class=vl-section-inner><header class=vl-section-header><h1 class=vl-section-heading><strong>Groupoids and skeletons of monoids and preorders</strong></h1><p class=vl-section-meta><time datetime=2022-06-14>14 Jun 2022</time></p></header><div class="vl-section-body vl-single"><p>A <em>monoid</em> <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>e</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(M,e,m)</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> is a set, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math> an element of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math> an associative binary operation on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>, can be viewed as a single object category. Take <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>0</mn></msub><mo>=</mo><mspace linebreak="newline"></mspace><mrow><mi>M</mi><mspace linebreak="newline"></mspace></mrow></mrow><annotation encoding="application/x-tex">M_0 = \\{M\\}</annotation></semantics></math> or <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>0</mn></msub><mo>=</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">M_0 = \emptyset</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_1</annotation></semantics></math> to be the elements of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>, that is, morphisms in this category are elements of the monoid (where <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">M_0</annotation></semantics></math> is the class of objects of the category and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_1</annotation></semantics></math> is the class of morphisms).</p><p>A <em>groupoid</em> is a category where every morphism is an isomorphism. Monoids are groupoids when every element of the monoid has an inverse. Since the morphisms of this category are elements of the monoid, if every element has an inverse, then every morphism is an isomorphism. So, monoids which are groupoids, are those monoids that are <em>groups</em>.</p><p>A <em>preorder</em> <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(P,R)</annotation></semantics></math>, is a set <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math> together with a reflexive, transitive relation <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math>. A preorder can be viewed as a category by letting <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub><mo>=</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">P_0 = P</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub><mo>=</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">P_1=R</annotation></semantics></math>.</p><p>A preorder is a groupoid when the relation <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math> is symmetric. That is, an <em>equivalence relation</em> on a set is a groupoid. Since, for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">x,y\in P</annotation></semantics></math>, if <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">(x,y)\in R</annotation></semantics></math> then there is a morphism <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x\to y</annotation></semantics></math>, and if <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>y</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">(y,x)\in R</annotation></semantics></math> then there is a morphism <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>→</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">y\to x</annotation></semantics></math>, inverse to the morphism <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x\to y</annotation></semantics></math>, so it is an isomorphism. If <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>R</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mo stretchy="false">(</mo><mi>y</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">(x,y)\in R \implies (y,x)\in R</annotation></semantics></math> then every morphism <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x\to y</annotation></semantics></math> has an inverse morphism <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>→</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">y\to x</annotation></semantics></math> and so every morphism is an isomorphism.</p><p>A <em>skeleton</em> is a category in which, for every object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo separator="true">,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A,B</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>≈</mo><mi>B</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>A</mi><mo>=</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\approx B\implies A=B</annotation></semantics></math>. That is, if two objects are isomorphic then they are equal.</p><p>A preorder is a skeleton when the relation <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math> is antisymmetric. That is, an <em>order</em> is a skeleton. An antisymmetric relation is a relation in which <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>R</mi><mo>∧</mo><mo stretchy="false">(</mo><mi>y</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>R</mi><mo stretchy="false">)</mo><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>x</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">((x,y)\in R \land (y,x)\in R) \implies x=y</annotation></semantics></math>. Isomorphisms in preorders are those elements of the relation where <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>R</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mo stretchy="false">(</mo><mi>y</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">(x,y)\in R \implies (y,x)\in R</annotation></semantics></math>. So in an order, if <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">(x,y)\in R</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>y</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">(y,x) \in R</annotation></semantics></math>, the morphism <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x\to y</annotation></semantics></math> is an isomorphism and the objects <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math> are equal as a result of the antisymmetry of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math>.</p></div></article></div></main><div class=vl-footer-note>© 2024 by Elias Judin</div></div></div></body></html>