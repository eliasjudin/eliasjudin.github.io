<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>hom-Sets — Elias Judin</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Hom-sets worked out in any category: hom-functors preserve identities and composition, and detect monos/epis by injectivity - notes for Lean 4 formalisation."><meta name=robots content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=theme-color content="#ffffff"><meta name=author content="Elias Judin"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><link rel=canonical href=https://eliasjudin.github.io/blog/hom-sets/><meta property="og:url" content="https://eliasjudin.github.io/blog/hom-sets/"><meta property="og:title" content="hom-Sets — Elias Judin"><meta property="og:description" content="Hom-sets worked out in any category: hom-functors preserve identities and composition, and detect monos/epis by injectivity - notes for Lean 4 formalisation."><meta property="og:type" content="article"><meta property="og:site_name" content="Elias Judin"><meta property="og:image" content="https://eliasjudin.github.io/assets/images/banner-social.png"><meta property="og:image:alt" content="hom-Sets — Elias Judin"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="hom-Sets — Elias Judin"><meta name=twitter:description content="Hom-sets worked out in any category: hom-functors preserve identities and composition, and detect monos/epis by injectivity - notes for Lean 4 formalisation."><meta name=twitter:image content="https://eliasjudin.github.io/assets/images/banner-social.png"><meta name=twitter:image:alt content="hom-Sets — Elias Judin"><link rel=alternate type=application/rss+xml title="Elias Judin" href=https://eliasjudin.github.io/index.xml><meta property="article:published_time" content="2022-12-15T10:00:00+02:00"><meta property="article:modified_time" content="2025-12-22T03:21:50+02:00"><link rel=icon type=image/svg+xml href=/favicon.svg><link rel=stylesheet href=/css/style.min.f1d49839b721c9f35bcda8b272d1ca57dcd26b1c6dfd19cd3d9d6686095413ec.css integrity="sha256-8dSYObchyfNbzaiyctHKV9zSaxxt/RnNPZ1mhglUE+w=" crossorigin=anonymous><script defer src=/js/tickers.min.f08a1d80d427b8fb84ae659d7799cba6661e94a2c36e4d9a9e353cce065c6cad.js integrity="sha256-8IodgNQnuPuErmWdd5nLpmYelKLDbk2anjU8zgZcbK0="></script><script type=application/ld+json>[{"@context":"https://schema.org","@id":"https://eliasjudin.github.io/#website","@type":"WebSite","description":"Elias Judin's academic website and mathematics research blog on category theory, universal algebra, topology, and sheaf theory.","inLanguage":"en","name":"Elias Judin","publisher":{"@id":"https://eliasjudin.github.io/#person","@type":"Person","affiliation":[{"@type":"Organization","name":"Harmonic","url":"https://harmonic.fun/"},{"@type":"CollegeOrUniversity","name":"University of Cape Town","url":"https://www.uct.ac.za/"}],"alumniOf":[{"@type":"CollegeOrUniversity","name":"University of Cape Town","url":"https://www.uct.ac.za/"},{"@type":"CollegeOrUniversity","name":"University of the Witwatersrand","url":"https://www.wits.ac.za/"},{"@type":"HighSchool","name":"King David Victory Park High School","url":"https://www.kingdavid.org.za/victory-park-high-school/"}],"award":["Master's Fellowship; UCT Building Research Active Academic Staff Grant (2023, 2024)","Myer Levinson (EMDIN) Scholar (2022, 2023, 2024)","Max Price and Deborah Posel Scholarship nominee (2022)","University Council Merit Scholarship, University of the Witwatersrand (2020, 2021)","Dean's List (University of the Witwatersrand, 2020 Year II, 2021 Year III)"],"jobTitle":"Lean4 mathematician and MSc Mathematics student","knowsAbout":["Category theory","Universal algebra","Topology","Sheaf theory","Lean theorem proving","Quantum computing"],"name":"Elias Judin","sameAs":["https://scholar.google.com/citations?user=fOYPVWwAAAAJ","https://orcid.org/0009-0009-3267-9204","https://www.semanticscholar.org/author/Elias-Judin/2276874240"],"url":"https://eliasjudin.github.io/"},"url":"https://eliasjudin.github.io/"},{"@context":"https://schema.org","@id":"https://eliasjudin.github.io/blog/hom-sets/#webpage","@type":"WebPage","description":"Hom-sets worked out in any category: hom-functors preserve identities and composition, and detect monos/epis by injectivity - notes for Lean 4 formalisation.","inLanguage":"en","isPartOf":{"@id":"https://eliasjudin.github.io/#website"},"name":"hom-Sets","primaryImageOfPage":{"@type":"ImageObject","url":"https://eliasjudin.github.io/assets/images/banner-social.png"},"url":"https://eliasjudin.github.io/blog/hom-sets/"},{"@context":"https://schema.org","@id":"https://eliasjudin.github.io/blog/hom-sets/#article","@type":"ScholarlyArticle","author":[{"@type":"Person","name":"Elias Judin"}],"dateModified":"2025-12-22T03:21:50+02:00","datePublished":"2022-12-15T10:00:00+02:00","description":"Hom-sets worked out in any category: hom-functors preserve identities and composition, and detect monos/epis by injectivity - notes for Lean 4 formalisation.","headline":"hom-Sets","image":["https://eliasjudin.github.io/assets/images/banner-social.png"],"inLanguage":"en","isPartOf":{"@id":"https://eliasjudin.github.io/#website"},"keywords":"category-theory","mainEntityOfPage":{"@id":"https://eliasjudin.github.io/blog/hom-sets/#webpage","@type":"WebPage"},"name":"hom-Sets","publisher":{"@id":"https://eliasjudin.github.io/#person","@type":"Person","affiliation":[{"@type":"Organization","name":"Harmonic","url":"https://harmonic.fun/"},{"@type":"CollegeOrUniversity","name":"University of Cape Town","url":"https://www.uct.ac.za/"}],"alumniOf":[{"@type":"CollegeOrUniversity","name":"University of Cape Town","url":"https://www.uct.ac.za/"},{"@type":"CollegeOrUniversity","name":"University of the Witwatersrand","url":"https://www.wits.ac.za/"},{"@type":"HighSchool","name":"King David Victory Park High School","url":"https://www.kingdavid.org.za/victory-park-high-school/"}],"award":["Master's Fellowship; UCT Building Research Active Academic Staff Grant (2023, 2024)","Myer Levinson (EMDIN) Scholar (2022, 2023, 2024)","Max Price and Deborah Posel Scholarship nominee (2022)","University Council Merit Scholarship, University of the Witwatersrand (2020, 2021)","Dean's List (University of the Witwatersrand, 2020 Year II, 2021 Year III)"],"jobTitle":"Lean4 mathematician and MSc Mathematics student","knowsAbout":["Category theory","Universal algebra","Topology","Sheaf theory","Lean theorem proving","Quantum computing"],"name":"Elias Judin","sameAs":["https://scholar.google.com/citations?user=fOYPVWwAAAAJ","https://orcid.org/0009-0009-3267-9204","https://www.semanticscholar.org/author/Elias-Judin/2276874240"],"url":"https://eliasjudin.github.io/"},"url":"https://eliasjudin.github.io/blog/hom-sets/","wordCount":298}]</script></head><body><a class=vl-skip-link href=#main>Skip to main content</a><div class=vl-page><div class=vl-frame><header class=vl-header role=banner><div class=vl-top><div><form class=vl-top-form aria-label="navigate site"><label class=vl-sr-only for=vl-top-select>navigate to page</label>
<select id=vl-top-select class=vl-top-select onchange="const option=this.options[this.selectedIndex];if(option&&!option.disabled){const e=option.value;e&&(window.location.href=e)}"><option value=placeholder disabled>navigate...</option><option value=/>home</option><option value=/blog/ selected>mathematics blog</option><option value=/log/>log</option><option value=/cv/>curriculum vitae</option><option value=separator-4 disabled>..................................................</option><option value=/contact/>contact</option><option value=https://github.com/eliasjudin>github</option><option value=https://za.linkedin.com/in/elias-judin-a6988325a>linkedin</option></select></form><nav class=vl-sr-only aria-label="Primary site navigation"><ul><li><a href=/>home</a></li><li><a href=/blog/ aria-current=page>mathematics blog</a></li><li><a href=/log/>log</a></li><li><a href=/cv/>curriculum vitae</a></li><li><a href=/contact/>contact</a></li><li><a href=https://github.com/eliasjudin>github</a></li><li><a href=https://za.linkedin.com/in/elias-judin-a6988325a>linkedin</a></li></ul></nav></div><div class=vl-top-title><a href=/ class=vl-top-title-link>Elias Judin</a></div></div><div id=vl-tickers class=vl-tickers role=presentation><div class=vl-ticker data-speed=medium><div class=vl-ticker-label aria-hidden=true>about</div><div class=vl-ticker-marquee><span class=vl-sr-only>about: Mathematician & AI engineer, category theory, universal algebra, topology & sheaf theory, formal verification, foundation-model infrastructure</span><div class=vl-ticker-track aria-hidden=true>&nbsp;: Mathematician & AI engineer : category theory : universal algebra : topology & sheaf theory : formal verification : foundation-model infrastructure :&nbsp;&nbsp;&nbsp;&nbsp;</div></div></div><div class=vl-ticker data-speed=fast><div class=vl-ticker-label aria-hidden=true>now</div><div class=vl-ticker-marquee><span class=vl-sr-only>now: may 2025 — Lean4 formalization (part-time), march 2025 — AMC/AIME Lean4 labeling, august 2024 — Weekly category seminars, march 2024 — Research grant 2024</span><div class=vl-ticker-track aria-hidden=true>&nbsp;:: may 2025 — Lean4 formalization (part-time) :: march 2025 — AMC/AIME Lean4 labeling :: august 2024 — Weekly category seminars :: march 2024 — Research grant 2024 ::&nbsp;&nbsp;&nbsp;&nbsp;</div></div></div><div class=vl-ticker data-speed=slow><div class=vl-ticker-label aria-hidden=true>affiliations</div><div class=vl-ticker-marquee><span class=vl-sr-only>affiliations: Harmonic, Project Numina, University of Cape Town, University of the Witwatersrand, Kili Technology, Lean Prover community, SAOTA</span><div class=vl-ticker-track aria-hidden=true>&nbsp;::: Harmonic ::: Project Numina ::: University of Cape Town ::: University of the Witwatersrand ::: Kili Technology ::: Lean Prover community ::: SAOTA :::&nbsp;&nbsp;&nbsp;&nbsp;</div></div></div></div></header><main id=main class=vl-main><div class="vl-section vl-section--post"><article class="vl-section-inner h-entry"><nav class=vl-breadcrumbs aria-label=Breadcrumb><ol class=vl-breadcrumbs-list><li class=vl-breadcrumbs-item><a href=https://eliasjudin.github.io/>Elias Judin</a></li><li class=vl-breadcrumbs-item><a href=https://eliasjudin.github.io/blog/>Blog</a></li><li class=vl-breadcrumbs-item><span aria-current=page>hom-Sets</span></li></ol></nav><header class=vl-section-header><h1 class="vl-section-heading p-name">hom-Sets</h1><p class=vl-section-meta><time class=dt-published datetime=2022-12-15>15 Dec 2022</time></p><p class=vl-section-meta><time class=dt-updated datetime=2025-12-22>Updated 22 Dec 2025</time></p></header><div class="vl-section-body vl-single e-content"><p>Category theory treats morphisms as first-class objects, so it is worth writing down the algebra of hom-sets carefully. The notes
below expand the original scratch calculations into a short walkthrough that explains why hom-functors preserve identities,
how they transport composition, and how they detect monomorphisms and epimorphisms. These are the results I keep returning to
when formalising material in Lean and when teaching first-year algebra students.</p><p>Let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> be a fixed category.</p><p>Consider a morphism <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f:A\to B</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math> then, for any object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><msub><mn>1</mn><mi>A</mi></msub><mo stretchy="false">)</mo><mo>:</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(X,1_A):\operatorname{hom}(X,A)\to\operatorname{hom}(X,A)</annotation></semantics></math> is the identity map of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(X,A)</annotation></semantics></math> since for any <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a\in A</annotation></semantics></math>,</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><msub><mn>1</mn><mi>A</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mn>1</mn><mi>A</mi></msub><mi>a</mi><mo>=</mo><mi>a</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}(X,1_A)(a)=1_Aa=a.</annotation></semantics></math><hr><p>Given <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><mi>B</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">g:B\to C</annotation></semantics></math> a morphism in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math>, we have that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>g</mi><mo stretchy="false">)</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>g</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>f</mi><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mi>f</mi><mi>a</mi><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>g</mi><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(X,g)\operatorname{hom}(X,f)(a) = \operatorname{hom}(X,g)(fa) = gfa = \operatorname{hom}(X,gf)(a)</annotation></semantics></math><p>and so <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>g</mi><mo stretchy="false">)</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>g</mi><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(X,g)\operatorname{hom}(X,f) = \operatorname{hom}(X,gf)</annotation></semantics></math>. Similarly, for a morphism <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>∈</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">c\in\operatorname{hom}(C,X)</annotation></semantics></math> we have that,</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><mi>X</mi><mo stretchy="false">)</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>g</mi><mo separator="true">,</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>c</mi><mi>g</mi><mo stretchy="false">)</mo><mo>=</mo><mi>c</mi><mi>g</mi><mi>f</mi><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>g</mi><mi>f</mi><mo separator="true">,</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(f,X)\operatorname{hom}(g,X)(c) = \operatorname{hom}(f,X)(cg) = cgf = \operatorname{hom}(gf,X)(c)</annotation></semantics></math><p>and so <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><mi>X</mi><mo stretchy="false">)</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>g</mi><mo separator="true">,</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>g</mi><mi>f</mi><mo separator="true">,</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(f,X)\operatorname{hom}(g,X) = \operatorname{hom}(gf,X)</annotation></semantics></math>.</p><hr><p>Consider morphisms <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f:A\to B</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">g:C\to D</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math>, we can define the induced map <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>g</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo><mo>:</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>D</mi><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(g,f):\operatorname{hom}(D,A)\to\operatorname{hom}(C,B)</annotation></semantics></math> for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>∈</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>D</mi><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d\in\operatorname{hom}(D,A)</annotation></semantics></math> by</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>g</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mi>d</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}(g,f)(d)=fdg</annotation></semantics></math><p>and we have that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>g</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>g</mi><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\operatorname{hom}(g,f)=\operatorname{hom}(C,f)\operatorname{hom}(g,A).</annotation></semantics></math><hr><p>For a morphism <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\textbf{Sets}</annotation></semantics></math> we have that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> is a monomorphism if and only if <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(X,f)</annotation></semantics></math> is injective for every object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\textbf{Sets}</annotation></semantics></math>. Suppose <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f:A\to B</annotation></semantics></math> is a monomorphism in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\textbf{Sets}</annotation></semantics></math>, then for any object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\textbf{Sets}</annotation></semantics></math> and any pair of parallel morphisms <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∈</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a,a&#x27;\in\operatorname{hom}(X,A)</annotation></semantics></math>, we have that</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>f</mi><mi>a</mi><mo>=</mo><mi>f</mi><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>a</mi><mo>=</mo><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">\operatorname{hom}(X,f)(a)=\operatorname{hom}(X,f)(a&#x27;)\implies fa=fa&#x27; \implies a = a&#x27;</annotation></semantics></math><p>since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> is a monomorphism. So, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(X,f)</annotation></semantics></math> is injective for any object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\textbf{Sets}</annotation></semantics></math>.
Conversely, suppose <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(X,f)</annotation></semantics></math> is injective for any object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>, then for any pair of parallel morphisms <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∈</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a,a&#x27;\in\operatorname{hom}(X,A)</annotation></semantics></math>,</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>a</mi><mo>=</mo><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">\operatorname{hom}(X,f)(a)=\operatorname{hom}(X,f)(a&#x27;)\implies a = a&#x27;</annotation></semantics></math><p>and so</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mi>a</mi><mo>=</mo><mi>f</mi><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>a</mi><mo>=</mo><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">fa=fa&#x27;\implies a=a&#x27;</annotation></semantics></math><p>hence, f is a monomorphism in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\textbf{Sets}</annotation></semantics></math>. Similarly, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> is an epimorphism in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">Sets</mtext></mrow><annotation encoding="application/x-tex">\textbf{Sets}</annotation></semantics></math> if and only if for every object <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> the map <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{hom}(f,X)</annotation></semantics></math> is injective.</p><footer class=vl-single-footer><p class="vl-section-meta vl-single-tags"><span class=vl-single-tags-label>Tags:</span>
<a class=p-category href=/tags/category-theory/ rel=tag>Category theory</a></p></footer></div></article></div></main><footer class=vl-footer role=contentinfo><div class=vl-footer-note>© 2025 by Elias Judin</div></footer></div></div></body></html>